<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Box Head – Mini Shooter (Refactored)</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #161a2e;
            --ink: #e7ecf3;
            --accent: #4de2cc;
        }

        html, body {
            margin: 0;
            height: 100%;
            background: radial-gradient(1200px 800px at 30% 20%, #1a1e36, var(--bg));
            color: var(--ink);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            background: color-mix(in oklab, var(--panel) 90%, black);
            padding: 10px 14px;
            border-radius: 14px;
            z-index: 20;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06)
        }

        .pill {
            background: #0f1430;
            padding: 6px 10px;
            border-radius: 999px;
            opacity: .9
        }

        .btn {
            cursor: pointer;
            padding: 8px 14px;
            border-radius: 12px;
            background: var(--accent);
            color: #012321;
            font-weight: 700;
            border: none
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: #0b0e1a;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.04)
        }

        .overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5,8,20,.55);
            backdrop-filter: saturate(120%) blur(4px);
            z-index: 30
        }

        .card {
            max-width: 820px;
            background: var(--panel);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,.5)
        }

        .row {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            align-items: center
        }

        .kbd {
            font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
            background: #0b1026;
            padding: 2px 6px;
            border-radius: 6px
        }
    </style>
</head>
<body>
    <div class="hud">
        <span class="pill">Våben: <b id="weapon">Pistol</b></span>
        <span class="pill">Ammo: <b id="ammo">∞</b></span>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Wave: <b id="wave">1</b></span>
        <span class="pill">HP: <b id="hp">100</b></span>
        <button id="restart" class="btn">Genstart</button>
    </div>

    <canvas id="game" width="1600" height="900"></canvas>

    <div class="overlay" id="startOverlay">
        <div class="card">
            <h2 id="overlayTitle" style="margin:0 0 8px">Velkommen til <span style="color:var(--accent)">Box Head</span></h2>
            <p style="margin:0 0 12px">Top‑down mini‑shooter. Saml våben, spar på ammo, og overlev så længe du kan! 💥</p>
            <div class="row">
                <div>
                    <div>Bevægelse: <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span></div>
                    <div>Sigte: mus • Skyd: venstre klik / <span class="kbd">Mellemrum</span></div>
                    <div>Dash: <span class="kbd">Shift</span> • Pause: <span class="kbd">P</span></div>
                    <div>Våben: <span class="kbd">1</span> Pistol (∞), <span class="kbd">2</span> Shotgun, <span class="kbd">3</span> Riffel, <span class="kbd">4</span> Sniper</div>
                </div>
                <button id="startBtn" class="btn">Start spil</button>
            </div>
        </div>
    </div>

    <script>
        'use strict';
        /**
         * Refactored single-file architecture (no external tooling needed)
         * "Modules" are plain objects grouped by responsibility.
         * - Config: constants & weapons
         * - Save: persistence (high score)
         * - State: all entity arrays & variables
         * - HUD: DOM updates
         * - Input: keyboard/mouse
         * - RNG/Math: helpers
         * - Map: obstacle generation (10–20 crates)
         * - Systems: Movement, Shooting, Collision, Pickups, Spawning, Effects
         * - Render: draw everything
         * - Game: fixed timestep loop + lifecycle
         */

        // ===== DOM =====
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        const hud = {
            weapon: document.getElementById('weapon'),
            ammo: document.getElementById('ammo'),
            score: document.getElementById('score'),
            wave: document.getElementById('wave'),
            hp: document.getElementById('hp'),
            startOverlay: document.getElementById('startOverlay'),
            startBtn: document.getElementById('startBtn'),
            overlayTitle: document.getElementById('overlayTitle'),
            restartBtn: document.getElementById('restart')
        };

        // ===== Config =====
        const Config = Object.freeze({
            bounds: { x: 60, y: 60, w: W - 120, h: H - 120 },
            friction: 0.86,
            dash: { cool: 900, speed: 7 },
            player: { speed: 0.5, size: 22, hp: 100 }, // 4× slower
            spawn: { perWaveBase: 6, perWaveScale: 1.1, maxBatch: 22 },
            pickups: { max: 8, spawnMin: 10000, spawnMax: 15000 },
            fixedDt: 1000 / 60, // physics step (ms)
        });

        const Weapons = [
            { key: '1', name: 'Pistol', dmg: 20, speed: 10, cd: 400, spread: 0.02, pellets: 1, pierce: 0, life: 900, ammoCost: 0, pickup: 0 },
            { key: '2', name: 'Shotgun', dmg: 14, speed: 9, cd: 600, spread: 0.18, pellets: 8, pierce: 0, life: 500, ammoCost: 1, pickup: 10 },
            { key: '3', name: 'Riffel', dmg: 22, speed: 14, cd: 90, spread: 0.01, pellets: 1, pierce: 0, life: 1100, ammoCost: 1, pickup: 30 },
            { key: '4', name: 'Sniper', dmg: 80, speed: 20, cd: 900, spread: 0.00, pellets: 1, pierce: 3, life: 4000, ammoCost: 1, pickup: 8 }
        ];

        // ===== Save (localStorage) =====
        const Save = {
            get highScore() { return parseInt(localStorage.getItem('boxhead_highscore')) || 0; },
            set highScore(v) { localStorage.setItem('boxhead_highscore', String(v | 0)); }
        };

        // ===== Math & RNG helpers =====
        const MathX = {
            rand(a, b) { return Math.random() * (b - a) + a; },
            clamp(v, a, b) { return Math.max(a, Math.min(b, v)); },
            norm(x, y) { const l = Math.hypot(x, y) || 1; return [x / l, y / l]; },
        };

        // ===== Input =====
        const Input = (() => {
            const keys = new Set();
            const mouse = { x: W / 2, y: H / 2, down: false };
            window.addEventListener('keydown', e => { if (e.code === 'KeyP') { Game.paused = !Game.paused; return; } if (e.code === 'Space') { mouse.down = true; } if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') { Systems.tryDash(); } keys.add(e.code); Systems.handleWeaponKeys(e.code); });
            window.addEventListener('keyup', e => { if (e.code === 'Space') { mouse.down = false; } keys.delete(e.code); });
            canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width / r.width); mouse.y = (e.clientY - r.top) * (canvas.height / r.height); });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            canvas.addEventListener('mouseup', () => mouse.down = false);
            return { keys, mouse };
        })();

        // ===== State =====
        const State = (() => {
            const player = { x: W / 2, y: H / 2, vx: 0, vy: 0, size: Config.player.size, speed: Config.player.speed, hp: Config.player.hp, alive: true };
            const bullets = []; // {x,y,vx,vy,life,damage,pierce}
            const enemies = []; // {x,y,vx,vy,size,hp,spd}
            const particles = []; // {x,y,vx,vy,life,c,full}
            const obstacles = []; // crates {x,y,w,h}
            const pickups = []; // {x,y,w,h,type}
            let weaponIndex = 0; // 0..3
            const ammo = { 1: Infinity, 2: 0, 3: 0, 4: 0 };
            let score = 0, wave = 1, spawnTimer = 0, pickupTimer = 0, lastFire = -1e9;
            let highScore = Save.highScore;
            return { player, bullets, enemies, particles, obstacles, pickups, weaponIndex, ammo, score, wave, spawnTimer, pickupTimer, lastFire, highScore };
        })();

        // ===== HUD =====
        const HUD = {
            update() {
                const w = Weapons[State.weaponIndex];
                hud.weapon.textContent = w.name;
                const a = State.ammo[State.weaponIndex + 1];
                hud.ammo.textContent = (a === Infinity) ? '∞' : String(a | 0);
                hud.score.textContent = State.score;
                hud.wave.textContent = State.wave;
                hud.hp.textContent = Math.max(0, Math.ceil(State.player.hp));
            },
            showOverlay(title) { if (hud.startOverlay) { hud.overlayTitle.textContent = title; hud.startOverlay.style.display = 'grid'; } },
            hideOverlay() { if (hud.startOverlay) hud.startOverlay.style.display = 'none'; },
        };

        // ===== Map generation (10–20 crates) =====
        const MapGen = {
            makeOpenArena() {
                State.obstacles.length = 0;
                const b = Config.bounds; const n = Math.floor(MathX.rand(10, 21));
                for (let i = 0; i < n; i++) {
                    const w = MathX.rand(60, 120), h = MathX.rand(60, 120);
                    const x = MathX.rand(b.x + 20, b.x + b.w - w - 20);
                    const y = MathX.rand(b.y + 20, b.y + b.h - h - 20);
                    const startSafe = { x: W / 2 - 200, y: H / 2 - 200, w: 400, h: 400 };
                    if (x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y) { i--; continue; }
                    State.obstacles.push({ x, y, w, h });
                }
            }
        };

        // ===== Systems =====
        const Systems = {
            // --- weapons ---
            handleWeaponKeys(code) {
                const map = { Digit1: 0, Digit2: 1, Digit3: 2, Digit4: 3 };
                if (code in map) { State.weaponIndex = map[code]; HUD.update(); }
            },
            tryDash() {
                const now = performance.now();
                if (!Systems._dashLast) Systems._dashLast = -9999;
                if (now - Systems._dashLast < Config.dash.cool) return;
                let dx = 0, dy = 0; const k = Input.keys; if (k.has('KeyW')) dy -= 1; if (k.has('KeyS')) dy += 1; if (k.has('KeyA')) dx -= 1; if (k.has('KeyD')) dx += 1; if (!dx && !dy) return;
                const [nx, ny] = MathX.norm(dx, dy); State.player.vx += nx * Config.dash.speed; State.player.vy += ny * Config.dash.speed; Systems.puff(State.player.x, State.player.y, 14, 4, 300, 'rgba(77,226,204,.75)'); Systems._dashLast = now;
            },
            shoot() {
                const w = Weapons[State.weaponIndex]; const now = performance.now(); if (now - State.lastFire < w.cd) return;
                if (w.ammoCost > 0) { const slot = State.weaponIndex + 1; if (!State.ammo[slot] || State.ammo[slot] <= 0) { State.lastFire = now; return; } State.ammo[slot] -= w.ammoCost; }
                State.lastFire = now;
                const dx = Input.mouse.x - State.player.x, dy = Input.mouse.y - State.player.y, baseAng = Math.atan2(dy, dx);
                for (let i = 0; i < w.pellets; i++) {
                    const ang = baseAng + MathX.rand(-w.spread, w.spread); const vx = Math.cos(ang) * w.speed, vy = Math.sin(ang) * w.speed;
                    State.bullets.push({ x: State.player.x + Math.cos(baseAng) * (State.player.size + 8), y: State.player.y + Math.sin(baseAng) * (State.player.size + 8), vx, vy, life: w.life, damage: w.dmg, pierce: w.pierce });
                }
                Systems.puff(State.player.x + Math.cos(baseAng) * 14, State.player.y + Math.sin(baseAng) * 14, 6 + w.pellets, 1.2, 160, 'rgba(255,255,255,.5)');
                HUD.update();
            },
            // --- movement ---
            movePlayer(dt) {
                let ax = 0, ay = 0; const k = Input.keys; if (k.has('KeyW')) ay -= 1; if (k.has('KeyS')) ay += 1; if (k.has('KeyA')) ax -= 1; if (k.has('KeyD')) ax += 1; if (ax || ay) { const [nx, ny] = MathX.norm(ax, ay); State.player.vx += nx * State.player.speed; State.player.vy += ny * State.player.speed; }
                State.player.vx *= Config.friction; State.player.vy *= Config.friction; State.player.x += State.player.vx; State.player.y += State.player.vy; Systems.resolveAABB(State.player, State.player.size);
            },
            moveBullets(dt) {
                for (let i = State.bullets.length - 1; i >= 0; i--) { const b = State.bullets[i]; b.x += b.vx; b.y += b.vy; b.life -= dt; let hit = false; for (const o of State.obstacles) { if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) { hit = true; break; } } if (hit) { Systems.puff(b.x, b.y, 6, 1.1, 200, 'rgba(230,236,243,.6)'); State.bullets.splice(i, 1); continue; } if (b.x < -50 || b.y < -50 || b.x > W + 50 || b.y > H + 50 || b.life <= 0) State.bullets.splice(i, 1); }
            },
            moveEnemies(dt) {
                for (const e of State.enemies) { const dx = State.player.x - e.x, dy = State.player.y - e.y, d = Math.hypot(dx, dy) + 1e-4; const s = e.spd * (1 + Math.min(0.6, 30 / d)); e.vx = (dx / d) * s; e.vy = (dy / d) * s; e.x += e.vx; e.y += e.vy; Systems.resolveAABB(e, e.size); }
            },
            // --- collisions ---
            resolveAABB(ent, size) {
                const b = Config.bounds; ent.x = MathX.clamp(ent.x, b.x + size / 2, b.x + b.w - size / 2); ent.y = MathX.clamp(ent.y, b.y + size / 2, b.y + b.h - size / 2);
                for (const o of State.obstacles) { const ex = ent.x - size / 2, ey = ent.y - size / 2, ew = size, eh = size; if (ex < o.x + o.w && ex + ew > o.x && ey < o.y + o.h && ey + eh > o.y) { const dx1 = (o.x + o.w) - ex, dx2 = (ex + ew) - o.x, dy1 = (o.y + o.h) - ey, dy2 = (ey + eh) - o.y; const m = Math.min(dx1, dx2, dy1, dy2); if (m === dx1) ent.x = o.x + o.w + size / 2; else if (m === dx2) ent.x = o.x - size / 2; else if (m === dy1) ent.y = o.y + o.h + size / 2; else ent.y = o.y - size / 2; } }
            },
            damageOnTouch(dt) {
                for (const e of State.enemies) { if (Math.hypot(State.player.x - e.x, State.player.y - e.y) < e.size + State.player.size - 6) { State.player.hp -= 10 * dt / 1000; if (State.player.hp <= 0) { Game.gameOver(); return; } if (Math.random() < 0.2) Systems.blood(State.player.x, State.player.y); } }
            },
            bulletsVsEnemies() {
                for (let i = State.enemies.length - 1; i >= 0; i--) { const e = State.enemies[i]; for (let j = State.bullets.length - 1; j >= 0; j--) { const b = State.bullets[j]; if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) { e.hp -= (b.damage || 20); if (e.hp <= 0) { Systems.puff(e.x, e.y, 18, 2.4, 500, 'rgba(255,107,107,.9)'); State.enemies.splice(i, 1); State.score += 10; } if (b.pierce && b.pierce > 0) { b.pierce--; Systems.blood(e.x, e.y); } else { State.bullets.splice(j, 1); Systems.blood(e.x, e.y); } break; } } }
            },
            // --- pickups ---
            spawnPickup() { const options = [2, 3, 3, 4]; const type = options[Math.floor(Math.random() * options.length)]; const b = Config.bounds; const w = 28, h = 28; for (let tries = 0; tries < 50; tries++) { const x = MathX.rand(b.x + 20, b.x + b.w - w - 20), y = MathX.rand(b.y + 20, b.y + b.h - h - 20); const startSafe = { x: W / 2 - 160, y: H / 2 - 160, w: 320, h: 320 }; let bad = x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y; for (const o of State.obstacles) { if (x < o.x + o.w && x + w > o.x && y < o.y + o.h && y + h > o.y) { bad = true; break; } } if (!bad) { State.pickups.push({ x, y, w, h, type }); break; } } },
            tryPickup() { for (let i = State.pickups.length - 1; i >= 0; i--) { const p = State.pickups[i]; if (State.player.x > p.x && State.player.x < p.x + p.w && State.player.y > p.y && State.player.y < p.y + p.h) { const w = Weapons[p.type - 1]; State.ammo[p.type] = (State.ammo[p.type] || 0) + w.pickup; State.pickups.splice(i, 1); HUD.update(); } } },
            // --- spawning ---
            spawnEnemy() { const edge = Math.floor(MathX.rand(0, 4)); let x, y; if (edge === 0) { x = MathX.rand(0, W); y = -20; } if (edge === 1) { x = W + 20; y = MathX.rand(0, H); } if (edge === 2) { x = MathX.rand(0, W); y = H + 20; } if (edge === 3) { x = -20; y = MathX.rand(0, H); } const size = MathX.rand(16, 28); const hp = 10 + State.wave * 2 + MathX.rand(-2, 2); const spd = 0.55 + Math.min(1.2, State.wave * 0.05) + MathX.rand(-0.08, 0.08); State.enemies.push({ x, y, vx: 0, vy: 0, size, hp, spd }); },
            nextWave() { State.wave++; for (let i = 0; i < Math.min(Config.spawn.perWaveBase + State.wave * Config.spawn.perWaveScale, Config.spawn.maxBatch); i++) Systems.spawnEnemy(); State.player.hp = MathX.clamp(State.player.hp + 12, 0, 100); Systems.flash('#4de2cc'); },
            // --- fx ---
            puff(x, y, n = 12, speed = 3, life = 500, c = 'rgba(255,255,255,.8)') { for (let i = 0; i < n; i++) { const a = MathX.rand(0, Math.PI * 2), v = MathX.rand(0.5, speed); State.particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life, c }); } },
            blood(x, y) { Systems.puff(x, y, 16, 2.6, 700, 'rgba(255,80,80,.8)'); },
            flash(color) { State.particles.push({ x: W / 2, y: H / 2, vx: 0, vy: 0, life: 160, c: color, full: true }); },
            updateParticles(dt) { for (let i = State.particles.length - 1; i >= 0; i--) { const p = State.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= dt; if (p.life <= 0) State.particles.splice(i, 1); } }
        };

        // ===== Render =====
        const Render = {
            draw() {
                ctx.clearRect(0, 0, W, H);
                const b = Config.bounds;
                // background & bounds
                ctx.save(); ctx.fillStyle = '#0a0e1b'; ctx.fillRect(0, 0, W, H); ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = 2; ctx.strokeRect(b.x - 10, b.y - 10, b.w + 20, b.h + 20); ctx.globalAlpha = .06; for (let x = b.x; x < b.x + b.w; x += 40) { ctx.beginPath(); ctx.moveTo(x, b.y); ctx.lineTo(x, b.y + b.h); ctx.stroke(); } for (let y = b.y; y < b.y + b.h; y += 40) { ctx.beginPath(); ctx.moveTo(b.x, y); ctx.lineTo(b.x + b.w, y); ctx.stroke(); } ctx.globalAlpha = 1; ctx.restore();
                // crates
                ctx.save(); for (const o of State.obstacles) { ctx.fillStyle = '#1e243f'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.strokeRect(o.x + 0.5, o.y + 0.5, o.w - 1, o.h - 1); } ctx.restore();
                // pickups
                ctx.save(); for (const p of State.pickups) { let col = '#ffb84d'; if (p.type === 3) col = '#4da6ff'; if (p.type === 4) col = '#b58dff'; ctx.fillStyle = col; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.strokeRect(p.x + 0.5, p.y + 0.5, p.w - 1, p.h - 1); } ctx.restore();
                // particles
                for (const p of State.particles) { if (p.full) { const t = MathX.clamp(p.life / 160, 0, 1); ctx.save(); ctx.globalAlpha = t * 0.25; ctx.fillStyle = p.c; ctx.fillRect(0, 0, W, H); ctx.restore(); } else { ctx.save(); ctx.globalAlpha = MathX.clamp(p.life / 500, 0, 1); ctx.fillStyle = p.c; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); ctx.restore(); } }
                // player
                if (State.player.alive) { const dx = Input.mouse.x - State.player.x, dy = Input.mouse.y - State.player.y; const [nx, ny] = MathX.norm(dx, dy); const head = 12, body = State.player.size; ctx.save(); ctx.translate(State.player.x, State.player.y); ctx.rotate(Math.atan2(ny, nx)); ctx.fillStyle = '#1b2a57'; ctx.fillRect(-body / 2, -body / 2, body, body); ctx.fillStyle = '#4de2cc'; ctx.fillRect(body / 2 - 2, -head / 2, head, head); ctx.fillStyle = '#e7ecf3'; ctx.fillRect(body / 2 + head - 2, -3, 16, 6); ctx.restore(); }
                // enemies
                for (const e of State.enemies) { ctx.save(); ctx.translate(e.x, e.y); ctx.fillStyle = '#ff6b6b'; ctx.fillRect(-e.size / 2, -e.size / 2, e.size, e.size); ctx.fillStyle = '#10131f'; ctx.fillRect(-4, -4, 3, 3); ctx.fillRect(1, -4, 3, 3); ctx.restore(); }
                // bullets
                ctx.save(); ctx.fillStyle = '#e7ecf3'; for (const b2 of State.bullets) { ctx.fillRect(b2.x - 2, b2.y - 2, 4, 4); } ctx.restore();
                // paused
                if (Game.paused) { ctx.save(); ctx.globalAlpha = .6; ctx.fillStyle = '#0b0f1e'; ctx.fillRect(0, 0, W, H); ctx.globalAlpha = 1; ctx.fillStyle = '#fff'; ctx.font = '700 36px system-ui, sans-serif'; ctx.textAlign = 'center'; ctx.fillText('PAUSE', W / 2, H / 2); ctx.restore(); }
            }
        };

        // ===== Game (lifecycle + fixed timestep) =====
        const Game = {
            running: false, paused: false,
            init() {
                MapGen.makeOpenArena();
                State.enemies.length = 0; State.bullets.length = 0; State.particles.length = 0; State.pickups.length = 0;
                State.player.x = W / 2; State.player.y = H / 2; State.player.vx = 0; State.player.vy = 0; State.player.hp = Config.player.hp; State.player.alive = true;
                State.weaponIndex = 0; State.ammo[2] = 0; State.ammo[3] = 0; State.ammo[4] = 0;
                State.score = 0; State.wave = 1; State.spawnTimer = 0; State.pickupTimer = 0; State.lastFire = -1e9;
                // seed a few pickups
                for (let i = 0; i < 4; i++) Systems.spawnPickup();
                HUD.update(); HUD.showOverlay('Velkommen til Box Head');
            },
            start() { this.running = true; this.paused = false; HUD.hideOverlay(); this._acc = 0; this._last = performance.now(); requestAnimationFrame(this.loop.bind(this)); },
            loop(ts) { if (!this.running) { return; } const frame = ts - this._last; this._last = ts; if (!this.paused) { this._acc = Math.min(this._acc + frame, 250); while (this._acc >= Config.fixedDt) { this.update(Config.fixedDt); this._acc -= Config.fixedDt; } this.render(); } requestAnimationFrame(this.loop.bind(this)); },
            update(dt) {
                // input actions
                if (Input.mouse.down) Systems.shoot();
                // movement
                Systems.movePlayer(dt); Systems.moveBullets(dt); Systems.moveEnemies(dt);
                // collisions & combat
                Systems.damageOnTouch(dt); Systems.bulletsVsEnemies(); Systems.updateParticles(dt);
                // pickups
                Systems.tryPickup();
                // spawning timers
                State.spawnTimer -= dt; State.pickupTimer -= dt;
                if (State.spawnTimer <= 0) { const perSec = Math.min(0.5 + State.wave * 0.18, 2.0); State.spawnTimer = 1000 / perSec; Systems.spawnEnemy(); }
                if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) { State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax); Systems.spawnPickup(); }
                if (State.score > State.wave * 150) { Systems.nextWave(); }
                HUD.update();
            },
            render() { Render.draw(); },
            gameOver() {
                if (!State.player.alive) return; State.player.alive = false; this.paused = false; // keep loop running for overlay
                if (State.score > State.highScore) { State.highScore = State.score; Save.highScore = State.highScore; }
                HUD.showOverlay(`Game Over – Score: ${State.score} (High Score: ${State.highScore})`);
            }
        };

        // ===== Wire up buttons =====
        if (hud.startBtn) hud.startBtn.addEventListener('click', () => Game.start());
        if (hud.restartBtn) hud.restartBtn.addEventListener('click', () => Game.init());

        // ===== Minimal Tests (console) =====
        (function runTests() {
            const assert = (cond, msg) => { if (!cond) throw new Error(msg); };
            const test = (name, fn) => { try { fn(); console.log('✅', name); } catch (e) { console.error('❌', name, e); } };
            // Init once to set up world
            Game.init();
            test('Crates count 10–20', () => { assert(State.obstacles.length >= 10 && State.obstacles.length <= 20, `crates=${State.obstacles.length}`); });
            test('Default weapon is Pistol', () => { assert(Weapons[State.weaponIndex].name === 'Pistol', 'not pistol'); });
            test('Player 4× slower', () => { assert(State.player.speed <= 0.6, 'speed too high'); });
            // Fire a sniper round and check pierce
            test('Sniper pierces', () => { State.weaponIndex = 3; State.lastFire = -1e9; const before = State.bullets.length; Systems.shoot(); assert(State.bullets.length > before, 'no bullet'); assert(State.bullets.at(-1).pierce > 0, 'no pierce'); State.weaponIndex = 0; });
            console.log('— Tests complete —');
        })();
    </script>
</body>
</html>
