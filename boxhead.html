<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Box Head – Mini Shooter</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #161a2e;
            --ink: #e7ecf3;
            --accent: #4de2cc
        }

        html, body {
            margin: 0;
            height: 100%;
            background: radial-gradient(1200px 800px at 30% 20%,#1a1e36,var(--bg));
            color: var(--ink);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            background: color-mix(in oklab,var(--panel) 90%,black);
            padding: 10px 14px;
            border-radius: 14px;
            z-index: 20;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06)
        }

        .pill {
            background: #0f1430;
            padding: 6px 10px;
            border-radius: 999px;
            opacity: .9
        }

        .btn {
            cursor: pointer;
            padding: 10px 14px;
            border-radius: 12px;
            background: var(--accent);
            color: #012321;
            font-weight: 800;
            border: none
        }

            .btn:disabled {
                opacity: .5;
                cursor: not-allowed
            }

        canvas {
            display: block;
            margin: 0 auto;
            background: #0b0e1a;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,.45),inset 0 0 0 1px rgba(255,255,255,.04)
        }

        .overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5,8,20,.55);
            backdrop-filter: saturate(120%) blur(4px);
            z-index: 30
        }

        .card {
            width: min(980px,calc(100% - 24px));
            background: var(--panel);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,.5)
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        .grid {
            display: grid;
            gap: 12px
        }

        .kbd {
            font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
            background: #0b1026;
            padding: 2px 6px;
            border-radius: 6px
        }

        .label {
            font-size: .95rem;
            opacity: .85
        }

        .input {
            flex: 1;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.08);
            background: #0b1026;
            color: var(--ink)
        }

        .small {
            font-size: .9rem;
            opacity: .8
        }

        .hidden {
            display: none !important
        }

        .host-pill {
            outline: 2px solid var(--accent)
        }

        .nameplate {
            font: 700 14px system-ui,sans-serif;
            text-align: left
        }

        .roomrow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-radius: 10px;
            background: #0b1026;
            border: 1px solid rgba(255,255,255,.06);
            margin-bottom: 8px
        }

            .roomrow.ingame {
                opacity: .6
            }

        .badge {
            font: 700 12px system-ui;
            padding: 2px 8px;
            border-radius: 999px;
            background: #0f1430
        }
    </style>
</head>
<body>
    <!-- HUD -->
    <div class="hud">
        <span class="pill">Våben: <b id="weapon">Pistol</b></span>
        <span class="pill">Ammo: <b id="ammo">∞</b></span>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Wave: <b id="wave">1</b></span>
        <span class="pill">HP: <b id="hp">100</b></span>
        <span class="pill" id="netpill">Net: <b id="role">—</b></span>
        <button id="restart" class="btn">Til menu</button>
    </div>

    <canvas id="game" width="1600" height="900"></canvas>

    <!-- MENU -->
    <div class="overlay" id="menu">
        <div class="card grid">
            <h2 style="margin:0">Box Head</h2>
            <div class="grid">
                <div class="label">Dit navn (bruges i multiplayer):</div>
                <div class="row"><input id="nameInput" class="input" maxlength="20" placeholder="Fx: Hedef" /></div>
            </div>
            <div class="row">
                <button id="spBtn" class="btn">Singleplayer</button>
                <button id="mpToggle" class="btn">Multiplayer</button>
            </div>
            <div id="mpPanel" class="grid hidden" style="margin-top:6px">
                <div class="label">Vælg/skriv rum-navn:</div>
                <div class="row">
                    <input id="roomInput" class="input" maxlength="24" placeholder="Fx: venner-aften" />
                    <button id="joinBtn" class="btn" disabled>Join lobby</button>
                </div>
                <div class="small">Tip: Aftal et rum-navn med dine venner. Hver gruppe bruger sit eget.</div>
                <div class="grid" style="margin-top:8px">
                    <div class="label">Aktive rum:</div>
                    <div id="roomsList"></div>
                    <div class="row">
                        <button id="refreshRooms" class="btn">Opdater rumliste</button>
                    </div>
                    <div id="joinError" class="small hidden" style="color:#ff9f9f">Rummet er i gang – vælg et andet eller vent.</div>
                </div>
            </div>
            <div class="small">
                <div>Bevægelse: <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span> • Dash: <span class="kbd">Shift</span></div>
                <div>Sigte: mus • Skyd: venstre klik / <span class="kbd">Mellemrum</span> • Pause: <span class="kbd">P</span></div>
                <div>Våben: <span class="kbd">1</span> Pistol (∞), <span class="kbd">2</span> Shotgun, <span class="kbd">3</span> Riffel</div>
            </div>
        </div>
    </div>

    <!-- LOBBY -->
    <div class="overlay hidden" id="lobby">
        <div class="card grid">
            <h2 style="margin:0">Lobby – <span id="roomName">—</span></h2>
            <div>Rolle: <b id="lobbyRole">—</b></div>
            <div class="row">
                <div style="min-width:260px; max-height:240px; overflow:auto; background:#0b1026; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px; flex:1">
                    <div class="small" style="margin-bottom:6px">Spillere i rummet:</div>
                    <div id="lobbyList" class="grid"></div>
                </div>
                <div class="grid" style="min-width:240px">
                    <button id="startMatchBtn" class="btn hidden">Start spil (host)</button>
                    <div id="waitMsg" class="small">Venter på at host starter…</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script>
        'use strict';
        const $ = id => document.getElementById(id);
        const show = id => $(id).classList.remove('hidden');
        const hide = id => $(id).classList.add('hidden');

        function h32(s) { let h = 2166136261 >>> 0; for (let i = 0; i < s.length; i++) { h ^= s.charCodeAt(i); h = Math.imul(h, 16777619) } return h >>> 0 }
        function xs32(seed) { let x = seed >>> 0; return () => { x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return (x >>> 0) / 4294967296 } }
        function detSym(id, uid, i) { return xs32((h32(id) ^ h32(uid) ^ (i * 0x9E3779B9)) >>> 0)() * 2 - 1 }

        /* ------------ NET ------------ */
        const NET = (() => {
            const HUB_URL = "https://www.hedef.dk/gamehub";
            const connection = new signalR.HubConnectionBuilder()
                .withUrl(HUB_URL, { withCredentials: false })
                .withAutomaticReconnect([0, 1000, 3000, 5000])
                .build();

            let myId = null, isHost = false, inGame = false, room = null, connected = false;
            const others = new Map();
            const names = new Map();
            let currentHostId = null;

            function roleHud() {
                $('role').textContent = isHost ? 'Host' : 'Client';
                $('netpill').classList.toggle('host-pill', isHost);
                $('lobbyRole').textContent = isHost ? 'Host' : 'Client';
                $('startMatchBtn').classList.toggle('hidden', !isHost);
            }
            function renderLobby() {
                $('roomName').textContent = room || '—';
                const list = $('lobbyList'); list.innerHTML = '';
                const ids = new Set(); if (myId) ids.add(myId); for (const id of others.keys()) ids.add(id);
                for (const id of ids) {
                    const div = document.createElement('div');
                    div.className = 'nameplate';
                    const n = names.get(id) || ('Spiller ' + (id || '').slice(-4));
                    div.textContent = (id === currentHostId ? '⭐ ' : '') + n;
                    list.appendChild(div);
                }
            }
            function renderRoomsList(snapshot) {
                const box = $('roomsList'); if (!box) return; box.innerHTML = '';
                snapshot.forEach(r => {
                    const row = document.createElement('div');
                    row.className = 'roomrow' + (r.inGame ? ' ingame' : '');
                    row.innerHTML = `<div><b>${r.name}</b><div class="small">${r.count} spiller(e)</div></div><div class="badge">${r.inGame ? 'I gang' : 'Åben'}</div>`;
                    if (!r.inGame) { row.style.cursor = 'pointer'; row.onclick = () => { $('roomInput').value = r.name; $('joinBtn').disabled = false; }; }
                    box.appendChild(row);
                });
            }

            async function ensureConnected() {
                if (connected) return;
                connection.on("Welcome", id => { myId = id; });
                connection.on("RoomsSnapshot", list => { renderRoomsList(list || []); });
                connection.on("RoomBusy", _ => { show('joinError'); });

                // server-sendt hostId i roster
                connection.on("Roster", (ids, hostId) => {
                    currentHostId = hostId || null;
                    const set = new Set(ids || []);
                    if (myId && !set.has(myId)) set.add(myId);
                    const newIsHost = (currentHostId === myId);
                    if (newIsHost !== isHost) { isHost = newIsHost; roleHud(); }
                    others.clear();
                    for (const id of set) { if (id !== myId) { others.set(id, { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0 }); } }
                    renderLobby();
                });

                connection.on("PlayerJoined", id => { others.set(id, { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0 }); renderLobby(); });
                connection.on("PlayerLeft", id => { others.delete(id); names.delete(id); renderLobby(); });
                connection.on("NamesSnapshot", dict => { names.clear(); for (const k in dict) names.set(k, dict[k]); renderLobby(); });
                connection.on("PlayerNamed", (id, name) => { names.set(id, name); renderLobby(); });
                connection.on("GameState", state => { inGame = !!state; });
                connection.on("HostChanged", hostId => { currentHostId = hostId; const newIsHost = (hostId === myId); if (newIsHost !== isHost) { isHost = newIsHost; roleHud(); } renderLobby(); });

                connection.on("JoinAccepted", rn => {
                    room = rn; connection.invoke("SetName", room, (State.myName || 'Spiller')).catch(() => { });
                    roleHud(); renderLobby(); hide('menu'); show('lobby');
                });

                connection.on("GameStarted", () => {
                    inGame = true; hide('lobby'); if (isHost && State.obstacles.length === 0) { MapGen.makeOpenArena(); sendObstaclesSnapshot(State.obstacles.map(o => ({ x: o.x, y: o.y, w: o.w, h: o.h }))); Game._sentObstacles = true; }
                    Game.startMatch('mp');
                });
                connection.on("GameEnded", () => { inGame = false; Game.endToLobby(); show('lobby'); });

                connection.on("State", (id, ps) => { if (id === myId) return; let o = others.get(id); if (!o) { o = { x: ps.x, y: ps.y, tx: ps.x, ty: ps.y, aim: ps.aim || 0, weaponIndex: 0 }; others.set(id, o); } o.tx = ps.x; o.ty = ps.y; o.aim = ps.aim || 0; });
                connection.on("WeaponChanged", (id, idx) => { if (id === myId) return; const o = others.get(id) || { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0 }; o.weaponIndex = idx | 0; others.set(id, o); });
                connection.on("Enemies", list => { if (!isHost) applyEnemies(list); });
                connection.on("Obstacles", list => { if (!isHost) applyObstacles(list); });
                // pickups sync til clients
                connection.on("Pickups", list => { if (!isHost) applyPickups(list); });

                connection.on("ShootRequest", (shooterId, payload) => { if (!isHost) return; if (ShotCache.has(payload.uid)) return; ShotCache.add(payload.uid); connection.invoke("ShootEvent", room, shooterId, payload).catch(() => { }); spawnShot(shooterId, payload, State.bullets); });
                connection.on("ShootEvent", (shooterId, payload) => { if (ShotCache.has(payload.uid)) return; ShotCache.add(payload.uid); const target = isHost ? State.bullets : Remote.bullets; spawnShot(shooterId, payload, target); });

                await connection.start(); connected = true;
                const list = await connection.invoke("GetRooms");
                renderRoomsList(list || []);
            }

            async function connectAndJoin(r, playerName) { await ensureConnected(); hide('joinError'); State.myName = playerName; await connection.invoke("Join", r); }
            function setName(n) { if (!room) return; names.set(myId, n); connection.invoke("SetName", room, n).catch(() => { }); }
            function startGame() { if (!room) return; connection.invoke("StartGame", room).catch(() => { }); }
            function endGame() { if (!room) return; connection.invoke("EndGame", room).catch(() => { }); }

            function leaveRoom() { if (!room) return; const r = room; room = null; connection.invoke("Leave", r).catch(() => { }); others.clear(); names.clear(); isHost = false; currentHostId = null; roleHud(); renderLobby(); }

            function sendState() { if (!room) return; const p = State.player; connection.invoke("UpdateSelf", { Room: room, X: p.x, Y: p.y, VX: p.vx, VY: p.vy, Aim: State.aim || 0, ClientTs: performance.now() | 0 }).catch(() => { }); }
            function sendEnemiesSnapshot(list) { if (isHost && room) connection.invoke("EnemiesSnapshot", room, list).catch(() => { }); }
            function sendObstaclesSnapshot(list) { if (isHost && room) connection.invoke("ObstaclesSnapshot", room, list).catch(() => { }); }
            function sendPickupsSnapshot(list) { if (isHost && room) connection.invoke("PickupsSnapshot", room, list).catch(() => { }); }
            function sendWeaponChanged(idx) { if (room) connection.invoke("WeaponChanged", room, idx | 0).catch(() => { }); }
            function sendShootRequest(payload) { if (room) connection.invoke("ShootRequest", room, payload).catch(() => { }); }
            function sendShootEvent(shooterId, payload) { if (room) connection.invoke("ShootEvent", room, shooterId, payload).catch(() => { }); }

            function getOthers() { return others; }
            function getIsHost() { return isHost; }
            function getMyId() { return myId; }
            function getName(id) { return names.get(id) || ""; }
            function getRoom() { return room; }
            async function fetchRooms() { try { const list = await connection.invoke("GetRooms"); renderRoomsList(list || []); } catch (e) { } }

            return { ensureConnected, connectAndJoin, setName, startGame, endGame, leaveRoom, sendState, sendEnemiesSnapshot, sendObstaclesSnapshot, sendPickupsSnapshot, sendWeaponChanged, sendShootRequest, sendShootEvent, getOthers, getIsHost, getMyId, getName, getRoom, fetchRooms };
        })();

        /* ------------ game state ------------ */
        const canvas = $('game'); const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        const Config = Object.freeze({
            bounds: { x: 60, y: 60, w: W - 120, h: H - 120 },
            friction: .86, dash: { cool: 900, speed: 7 }, player: { speed: .5, size: 22, hp: 100 },
            spawn: { perWaveBase: 6, perWaveScale: 1.1, maxBatch: 22 },
            pickups: { max: 3, spawnMin: 20000, spawnMax: 30000 },
            fixedDt: 1000 / 60
        });

        const Weapons = [
            { key: '1', name: 'Pistol', dmg: 20, speed: 10, cd: 500, spread: .02, pellets: 1, pierce: 0, life: 900, ammoCost: 0, pickup: 0 },
            { key: '2', name: 'Shotgun', dmg: 14, speed: 9, cd: 600, spread: .18, pellets: 8, pierce: 0, life: 500, ammoCost: 1, pickup: 40 },
            { key: '3', name: 'Riffel', dmg: 22, speed: 14, cd: 90, spread: .01, pellets: 1, pierce: 0, life: 1100, ammoCost: 1, pickup: 120 }
        ];

        const Save = { get highScore() { return parseInt(localStorage.getItem('boxhead_highscore')) || 0; }, set highScore(v) { localStorage.setItem('boxhead_highscore', String(v | 0)); } };
        const hud = { weapon: $('weapon'), ammo: $('ammo'), score: $('score'), wave: $('wave'), hp: $('hp') };
        const MathX = { rand(a, b) { return Math.random() * (b - a) + a; }, clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }, norm(x, y) { const l = Math.hypot(x, y) || 1; return [x / l, y / l]; } };

        const Input = (() => {
            const keys = new Set(); const mouse = { x: W / 2, y: H / 2, down: false };
            window.addEventListener('keydown', e => { if (e.code === 'KeyP') { Game.paused = !Game.paused; return; } if (e.code === 'Space') { mouse.down = true; } if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') Systems.tryDash(); keys.add(e.code); Systems.handleWeaponKeys(e.code); });
            window.addEventListener('keyup', e => { if (e.code === 'Space') mouse.down = false; keys.delete(e.code); });
            canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width / r.width); mouse.y = (e.clientY - r.top) * (canvas.height / r.height); });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            canvas.addEventListener('mouseup', () => mouse.down = false);
            return { keys, mouse };
        })();

        const State = (() => {
            const player = { x: W / 2, y: H / 2, vx: 0, vy: 0, size: Config.player.size, speed: Config.player.speed, hp: Config.player.hp, alive: true };
            const bullets = [], enemies = [], particles = [], obstacles = [], pickups = [];
            let weaponIndex = 0; const ammo = { 1: Infinity, 2: 0, 3: 0 };
            let score = 0, wave = 1, spawnTimer = 0, pickupTimer = 0, lastFire = -1e9;
            let highScore = Save.highScore; let myName = ''; let aim = 0;
            return { player, bullets, enemies, particles, obstacles, pickups, weaponIndex, ammo, score, wave, spawnTimer, pickupTimer, lastFire, highScore, myName, aim };
        })();

        const Remote = { bullets: [] };
        const ShotCache = new Set();

        function toMenu() { show('menu'); hide('lobby'); $('roomInput').value = ''; $('joinBtn').disabled = true; NET.leaveRoom(); }
        function toLobby() { hide('menu'); show('lobby'); }

        $('mpToggle').onclick = async () => { $('mpPanel').classList.toggle('hidden'); if (!$('mpPanel').classList.contains('hidden')) { await NET.ensureConnected(); } };
        $('roomInput').oninput = () => $('joinBtn').disabled = !$('roomInput').value.trim();
        $('restart').onclick = () => { Game.endToMenu(); };
        $('spBtn').onclick = () => { const nm = $('nameInput').value.trim().slice(0, 20); State.myName = nm || 'Spiller'; hide('menu'); Game.startMatch('sp'); };
        $('joinBtn').onclick = async () => {
            hide('joinError');
            const nm = ($('nameInput').value || '').trim().slice(0, 20) || 'Spiller';
            const room = $('roomInput').value.trim().toLowerCase().replace(/[^a-z0-9\-_.]/g, '-').slice(0, 24);
            if (!room) return;
            await NET.connectAndJoin(room, nm);
        };
        $('refreshRooms').onclick = async () => { await NET.ensureConnected(); await NET.fetchRooms(); };
        $('startMatchBtn').onclick = () => { NET.startGame(); };

        function HUDupdate() { const w = Weapons[State.weaponIndex]; hud.weapon.textContent = w.name; const a = State.ammo[State.weaponIndex + 1]; hud.ammo.textContent = (a === Infinity) ? '∞' : String(a | 0); hud.score.textContent = State.score; hud.wave.textContent = State.wave; hud.hp.textContent = Math.max(0, Math.ceil(State.player.hp)); }

        const MapGen = { makeOpenArena() { State.obstacles.length = 0; const b = Config.bounds; const n = Math.floor(MathX.rand(10, 21)); for (let i = 0; i < n; i++) { const w = MathX.rand(60, 120), h = MathX.rand(60, 120); const x = MathX.rand(b.x + 20, b.x + b.w - w - 20); const y = MathX.rand(b.y + 20, b.y + b.h - h - 20); const startSafe = { x: W / 2 - 200, y: H / 2 - 200, w: 400, h: 400 }; if (x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y) { i--; continue; } State.obstacles.push({ x, y, w, h }); } } };
        function applyEnemies(list) { State.enemies.length = 0; for (const e of list) State.enemies.push({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color, vx: 0, vy: 0 }); }
        function applyObstacles(list) { State.obstacles.length = 0; for (const o of list) State.obstacles.push({ x: o.x, y: o.y, w: o.w, h: o.h }); }
        function applyPickups(list) { State.pickups.length = 0; for (const p of list) State.pickups.push({ x: p.x, y: p.y, w: p.w, h: p.h, type: p.type }); }

        const Particles = {
            puff(x, y, n = 12, speed = 3, life = 500, color = 'rgba(255,255,255,1)') {
                for (let i = 0; i < n; i++) { const a = MathX.rand(0, Math.PI * 2), v = MathX.rand(.5, speed); State.particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life, max: life, color, full: false }); }
            },
            flash(color) { State.particles.push({ x: W / 2, y: H / 2, vx: 0, vy: 0, life: 160, max: 160, color, full: true }); },
            update(dt) { for (let i = State.particles.length - 1; i >= 0; i--) { const p = State.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= dt; if (p.life <= 0) State.particles.splice(i, 1); } },
            render(ctx) { for (const p of State.particles) { if (p.full) { const t = Math.max(0, p.life / p.max); ctx.save(); ctx.globalAlpha = .25 * t; ctx.fillStyle = p.color; ctx.fillRect(0, 0, W, H); ctx.restore(); } else { const t = Math.max(0, p.life / p.max); ctx.save(); ctx.globalAlpha = t * t; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } } }
        };

        const Systems = {
            handleWeaponKeys(code) { const map = { Digit1: 0, Digit2: 1, Digit3: 2 }; if (code in map) { State.weaponIndex = map[code]; if (Game.mode === 'mp') NET.sendWeaponChanged(State.weaponIndex); HUDupdate(); } },
            tryDash() { const now = performance.now(); if (!Systems._dashLast) Systems._dashLast = -9999; if (now - Systems._dashLast < Config.dash.cool) return; let dx = 0, dy = 0; const k = Input.keys; if (k.has('KeyW')) dy -= 1; if (k.has('KeyS')) dy += 1; if (k.has('KeyA')) dx -= 1; if (k.has('KeyD')) dx += 1; if (!dx && !dy) return; const [nx, ny] = MathX.norm(dx, dy); State.player.vx += nx * Config.dash.speed; State.player.vy += ny * Config.dash.speed; Particles.puff(State.player.x, State.player.y, 14, 4, 300, 'rgba(77,226,204,1)'); Systems._dashLast = now; },
            shoot() { const w = Weapons[State.weaponIndex]; const now = performance.now(); if (now - State.lastFire < w.cd) return; if (w.ammoCost > 0) { const slot = State.weaponIndex + 1; if (!State.ammo[slot] || State.ammo[slot] <= 0) { State.lastFire = now; return; } State.ammo[slot] -= w.ammoCost; } State.lastFire = now; const uid = (Game.mode === 'mp' ? (NET.getMyId() || 'me') : 'sp') + ':' + (now | 0) + ':' + State.weaponIndex; const payload = { x: State.player.x, y: State.player.y, angle: State.aim, weaponIndex: State.weaponIndex, ts: now | 0, uid }; if (Game.mode === 'mp') { if (NET.getIsHost()) { NET.sendShootEvent(NET.getMyId() || "", payload); if (!ShotCache.has(uid)) { ShotCache.add(uid); spawnShot(NET.getMyId() || "", payload, State.bullets); } } else { NET.sendShootRequest(payload); } } else { spawnShot('sp', payload, Remote.bullets); } HUDupdate(); },
            movePlayer(dt) { let ax = 0, ay = 0; const k = Input.keys; if (k.has('KeyW')) ay -= 1; if (k.has('KeyS')) ay += 1; if (k.has('KeyA')) ax -= 1; if (k.has('KeyD')) ax += 1; if (ax || ay) { const [nx, ny] = MathX.norm(ax, ay); State.player.vx += nx * State.player.speed; State.player.vy += ny * State.player.speed; } State.player.vx *= Config.friction; State.player.vy *= Config.friction; State.player.x += State.player.vx; State.player.y += State.player.vy; Systems.resolveAABB(State.player, State.player.size); },
            moveBullets(dt, list) { for (let i = list.length - 1; i >= 0; i--) { const b = list[i]; b.x += b.vx; b.y += b.vy; b.life -= dt; let hit = false; for (const o of State.obstacles) { if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) { hit = true; break; } } if (hit) { Particles.puff(b.x, b.y, 6, 1.1, 200, 'rgba(230,236,243,1)'); list.splice(i, 1); continue; } if (b.x < -50 || b.y < -50 || b.x > W + 50 || b.y > H + 50 || b.life <= 0) list.splice(i, 1); } },
            cullRemoteBullets() { for (let i = Remote.bullets.length - 1; i >= 0; i--) { const b = Remote.bullets[i]; for (const e of State.enemies) { if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) { Remote.bullets.splice(i, 1); break; } } } },
            moveEnemies(dt) { const targets = [{ x: State.player.x, y: State.player.y }]; if (Game.mode === 'mp') { for (const [, o] of NET.getOthers()) { targets.push({ x: o.tx ?? o.x, y: o.ty ?? o.y }); } } for (const e of State.enemies) { let tx = targets[0].x, ty = targets[0].y, best = Infinity; for (const t of targets) { const d2 = (t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y); if (d2 < best) { best = d2; tx = t.x; ty = t.y; } } const dx = tx - e.x, dy = ty - e.y, d = Math.hypot(dx, dy) + 1e-4; const s = e.spd * (1 + Math.min(.6, 30 / d)); e.vx = (dx / d) * s; e.vy = (dy / d) * s; e.x += e.vx; e.y += e.vy; Systems.resolveAABB(e, e.size); } },
            resolveAABB(ent, size) { const b = Config.bounds; ent.x = MathX.clamp(ent.x, b.x + size / 2, b.x + b.w - size / 2); ent.y = MathX.clamp(ent.y, b.y + size / 2, b.y + b.h - size / 2); for (const o of State.obstacles) { const ex = ent.x - size / 2, ey = ent.y - size / 2, ew = size, eh = size; if (ex < o.x + o.w && ex + ew > o.x && ey < o.y + o.h && ey + eh > o.y) { const dx1 = (o.x + o.w) - ex, dx2 = (ex + ew) - o.x, dy1 = (o.y + o.h) - ey, dy2 = (ey + eh) - o.y; const m = Math.min(dx1, dx2, dy1, dy2); if (m === dx1) ent.x = o.x + o.w + size / 2; else if (m === dx2) ent.x = o.x - size / 2; else if (m === dy1) ent.y = o.y + o.h + size / 2; else ent.y = o.y - size / 2; } } },
            damageOnTouch(dt) { for (const e of State.enemies) { if (Math.hypot(State.player.x - e.x, State.player.y - e.y) < e.size + State.player.size - 6) { State.player.hp -= 10 * dt / 1000; if (State.player.hp <= 0) { Game.onLocalDeath(); return; } if (Math.random() < .2) Particles.puff(State.player.x, State.player.y, 12, 2.0, 500, 'rgba(255,80,80,1)'); } } },
            bulletsVsEnemies(list) { for (let i = State.enemies.length - 1; i >= 0; i--) { const e = State.enemies[i]; for (let j = list.length - 1; j >= 0; j--) { const b = list[j]; if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) { e.hp -= (b.damage || 20); if (e.hp <= 0) { Particles.puff(e.x, e.y, 18, 2.4, 500, 'rgba(255,107,107,1)'); State.enemies.splice(i, 1); State.score += 10; } if (b.pierce && b.pierce > 0) { b.pierce--; Particles.puff(e.x, e.y, 8, 2.0, 400, 'rgba(255,80,80,1)'); } else { list.splice(j, 1); Particles.puff(e.x, e.y, 8, 2.0, 400, 'rgba(255,80,80,1)'); } break; } } } },
            spawnPickup() { const options = [2, 3, 3]; const type = options[Math.floor(Math.random() * options.length)]; const b = Config.bounds; const w = 28, h = 28; for (let tries = 0; tries < 50; tries++) { const x = MathX.rand(b.x + 20, b.x + b.w - w - 20), y = MathX.rand(b.y + 20, b.y + b.h - h - 20); const startSafe = { x: W / 2 - 160, y: H / 2 - 160, w: 320, h: 320 }; let bad = x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y; for (const o of State.obstacles) { if (x < o.x + o.w && x + w > o.x && y < o.y + o.h && y + h > o.y) { bad = true; break; } } if (!bad) { State.pickups.push({ x, y, w, h, type }); break; } } },
            tryPickup() {
                if (Game.mode === 'mp' && !NET.getIsHost()) return;
                let changed = false;
                for (let i = State.pickups.length - 1; i >= 0; i--) { const p = State.pickups[i]; if (State.player.x > p.x && State.player.x < p.x + p.w && State.player.y > p.y && State.player.y < p.y + p.h) { const w = Weapons[p.type - 1]; State.ammo[p.type] = (State.ammo[p.type] || 0) + w.pickup; State.pickups.splice(i, 1); changed = true; HUDupdate(); } }
                if (changed && Game.mode === 'mp' && NET.getIsHost()) {
                    NET.sendPickupsSnapshot(State.pickups.map(p => ({ x: p.x, y: p.y, w: p.w, h: p.h, type: p.type })));
                }
            },
            spawnEnemy() { const edge = Math.floor(MathX.rand(0, 4)); let x, y; if (edge === 0) { x = MathX.rand(0, W); y = -20; } if (edge === 1) { x = W + 20; y = MathX.rand(0, H); } if (edge === 2) { x = MathX.rand(0, W); y = H + 20; } if (edge === 3) { x = -20; y = MathX.rand(0, H); } const r = Math.random(); let type, size, hp, spd, color; if (r < .75) { type = 'normal'; size = MathX.rand(16, 24); hp = 10 + State.wave * 2 + MathX.rand(-2, 2); spd = .55 + Math.min(1.2, State.wave * .05) + MathX.rand(-.08, .08); color = '#ff6b6b'; } else { type = 'big'; size = MathX.rand(36, 44); hp = 150 + State.wave * 6 + MathX.rand(-4, 4); spd = .35 + Math.min(.7, State.wave * .03) + MathX.rand(-.05, .05); color = '#ff9f43'; } State.enemies.push({ x, y, vx: 0, vy: 0, size, hp, spd, type, color }); },
            nextWave() { State.wave++; for (let i = 0; i < Math.min(Config.spawn.perWaveBase + State.wave * Config.spawn.perWaveScale, Config.spawn.maxBatch); i++) Systems.spawnEnemy(); State.player.hp = MathX.clamp(State.player.hp + 12, 0, 100); Particles.flash('#4de2cc'); }
        };

        function spawnShot(shooterId, payload, list) { const w = Weapons[payload.weaponIndex]; const base = payload.angle; for (let i = 0; i < w.pellets; i++) { const ang = base + w.spread * detSym(shooterId, payload.uid, i); const vx = Math.cos(ang) * w.speed, vy = Math.sin(ang) * w.speed; list.push({ x: payload.x + Math.cos(base) * (State.player.size + 8), y: payload.y + Math.sin(base) * (State.player.size + 8), vx, vy, life: w.life, damage: w.dmg, pierce: w.pierce }); } Particles.puff(payload.x + Math.cos(base) * 14, payload.y + Math.sin(base) * 14, 6 + w.pellets, 1.2, 160, 'rgba(255,255,255,1)'); }

        /* ------------ render ------------ */
        const Render = {
            draw() {
                ctx.clearRect(0, 0, W, H); const b = Config.bounds;
                ctx.save(); ctx.fillStyle = '#0a0e1b'; ctx.fillRect(0, 0, W, H); ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = 2; ctx.strokeRect(b.x - 10, b.y - 10, b.w + 20, b.h + 20); ctx.globalAlpha = .06; for (let x = b.x; x < b.x + b.w; x += 40) { ctx.beginPath(); ctx.moveTo(x, b.y); ctx.lineTo(x, b.y + b.h); ctx.stroke(); } for (let y = b.y; y < b.y + b.h; y += 40) { ctx.beginPath(); ctx.moveTo(b.x, y); ctx.lineTo(b.x + b.w, y); ctx.stroke(); } ctx.globalAlpha = 1; ctx.restore();
                // crates
                ctx.save(); for (const o of State.obstacles) { ctx.fillStyle = '#1e243f'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.strokeRect(o.x + .5, o.y + .5, o.w - 1, o.h - 1); } ctx.restore();
                // pickups
                ctx.save(); for (const p of State.pickups) { let col = '#ffb84d'; if (p.type === 3) col = '#4da6ff'; ctx.fillStyle = col; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.strokeRect(p.x + .5, p.y + .5, p.w - 1, p.h - 1); } ctx.restore();
                // particles
                Particles.render(ctx);
                // players + weapon models
                function drawGun(model) { ctx.save(); ctx.fillStyle = model.color; ctx.fillRect(model.barrelL, model.barrelT, model.barrelW, model.barrelH); ctx.restore(); }
                function weaponModel(idx) { if (idx === 0) return { barrelL: 8, barrelT: -3, barrelW: 10, barrelH: 6, color: '#e7ecf3' }; if (idx === 1) return { barrelL: 8, barrelT: -5, barrelW: 18, barrelH: 10, color: '#e7ecf3' }; return { barrelL: 8, barrelT: -2, barrelW: 24, barrelH: 4, color: '#e7ecf3' }; }
                function drawPlayer(x, y, aim, isSelf, name, weaponIdx) { const s = 22, head = 12; ctx.save(); ctx.translate(x, y); ctx.rotate(aim || 0); ctx.fillStyle = isSelf ? '#1b2a57' : '#2a335f'; ctx.fillRect(-s / 2, -s / 2, s, s); ctx.fillStyle = isSelf ? '#4de2cc' : '#9aa7ff'; ctx.fillRect(s / 2 - 2, -head / 2, head, head); drawGun(weaponModel(weaponIdx)); ctx.restore(); if (name) { ctx.save(); ctx.fillStyle = 'rgba(0,0,0,.45)'; ctx.fillRect(x - 60, y - 38, 120, 22); ctx.fillStyle = '#e7ecf3'; ctx.font = '700 14px system-ui,sans-serif'; ctx.textAlign = 'center'; ctx.fillText(name, x, y - 22); ctx.restore(); } }
                drawPlayer(State.player.x, State.player.y, State.aim, true, State.myName, State.weaponIndex);
                if (Game.mode === 'mp') { for (const [id, o] of NET.getOthers()) { drawPlayer(o.x, o.y, o.aim || 0, false, NET.getName(id), o.weaponIndex | 0); } }
                for (const e of State.enemies) { ctx.save(); ctx.translate(e.x, e.y); ctx.fillStyle = e.color || '#ff6b6b'; ctx.fillRect(-e.size / 2, -e.size / 2, e.size, e.size); ctx.fillStyle = '#10131f'; ctx.fillRect(-4, -4, 3, 3); ctx.fillRect(1, -4, 3, 3); ctx.restore(); }
                ctx.save(); ctx.fillStyle = '#e7ecf3'; const bl = (Game.mode === 'mp' ? (NET.getIsHost() ? State.bullets : Remote.bullets) : Remote.bullets); for (const b2 of bl) ctx.fillRect(b2.x - 2, b2.y - 2, 4, 4); ctx.restore();
            }
        };

        const Game = {
            mode: 'sp', running: false, paused: false, _loop: 0, _sentObstacles: false,
            startMatch(mode) {
                this.mode = mode; this.running = true; this.paused = false; State.enemies.length = 0; State.bullets.length = 0; Remote.bullets.length = 0; State.particles.length = 0; State.pickups.length = 0; State.player.x = W / 2; State.player.y = H / 2; State.player.vx = 0; State.player.vy = 0; State.player.hp = Config.player.hp; State.player.alive = true; State.weaponIndex = 0; State.ammo[2] = 0; State.ammo[3] = 0; State.score = 0; State.wave = 1; State.spawnTimer = 0; State.pickupTimer = 0; State.lastFire = -1e9; if (mode === 'sp') { MapGen.makeOpenArena(); }
                let last = performance.now(), acc = 0, dt = Config.fixedDt; const loop = (ts) => { if (!this.running) return; const frame = ts - last; last = ts; if (!this.paused) { acc = Math.min(acc + frame, 250); while (acc >= dt) { this.update(dt); acc -= dt; } Render.draw(); HUDupdate(); } this._loop = requestAnimationFrame(loop); }; cancelAnimationFrame(this._loop); this._loop = requestAnimationFrame(loop);
                if (mode === 'mp') {
                    const tick = () => {
                        if (!this.running) return; if (NET.getIsHost()) {
                            const es = State.enemies.map(e => ({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color }));
                            NET.sendEnemiesSnapshot(es);
                            if (!this._sentObstacles && State.obstacles.length > 0) { NET.sendObstaclesSnapshot(State.obstacles.map(o => ({ x: o.x, y: o.y, w: o.w, h: o.h }))); this._sentObstacles = true; }
                            NET.sendPickupsSnapshot(State.pickups.map(p => ({ x: p.x, y: p.y, w: p.w, h: p.h, type: p.type })));
                        }
                        setTimeout(tick, 50);
                    }; tick();
                }
            },
            update(dt) {
                const dx = Input.mouse.x - State.player.x, dy = Input.mouse.y - State.player.y; State.aim = Math.atan2(dy, dx); if (Input.mouse.down) Systems.shoot(); Systems.movePlayer(dt);
                if (this.mode === 'mp') {
                    if (NET.getIsHost()) {
                        Systems.moveEnemies(dt); Systems.damageOnTouch(dt); Systems.bulletsVsEnemies(State.bullets); Systems.moveBullets(dt, State.bullets);
                        State.spawnTimer -= dt; State.pickupTimer -= dt;
                        if (State.spawnTimer <= 0) { const perSec = Math.min(.5 + State.wave * .18, 2.0); State.spawnTimer = 1000 / perSec; Systems.spawnEnemy(); }
                        if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) {
                            State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax); Systems.spawnPickup(); NET.sendPickupsSnapshot(State.pickups.map(p => ({ x: p.x, y: p.y, w: p.w, h: p.h, type: p.type })));
                        }
                        if (State.score > State.wave * 150) Systems.nextWave();
                    } else {
                        Systems.moveBullets(dt, Remote.bullets); Systems.cullRemoteBullets();
                    }
                    NET.sendState();
                    for (const [, o] of NET.getOthers()) { const s = .18; o.x += (o.tx - o.x) * s; o.y += (o.ty - o.y) * s; }
                } else {
                    Systems.moveEnemies(dt); Systems.damageOnTouch(dt); Systems.bulletsVsEnemies(Remote.bullets); Systems.moveBullets(dt, Remote.bullets);
                    State.spawnTimer -= dt; State.pickupTimer -= dt;
                    if (State.spawnTimer <= 0) { const perSec = Math.min(.5 + State.wave * .18, 2.0); State.spawnTimer = 1000 / perSec; Systems.spawnEnemy(); }
                    if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) { State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax); Systems.spawnPickup(); }
                    if (State.score > State.wave * 150) Systems.nextWave();
                }
                Particles.update(dt); Systems.tryPickup();
            },
            onLocalDeath() { State.player.alive = false; if (this.mode === 'mp') { if (NET.getIsHost()) NET.endGame(); } else { this.endToMenu(); } },
            endToLobby() { this.running = false; this.paused = false; show('lobby'); },
            endToMenu() { this.running = false; this.paused = false; toMenu(); }
        };

        toMenu();
        NET.ensureConnected();
    </script>
</body>
</html>