<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Box Head – Mini Shooter</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #161a2e;
            --ink: #e7ecf3;
            --accent: #4de2cc;
        }

        html, body {
            margin: 0;
            height: 100%;
            background: radial-gradient(1200px 800px at 30% 20%, #1a1e36, var(--bg));
            color: var(--ink);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            background: color-mix(in oklab, var(--panel) 90%, black);
            padding: 10px 14px;
            border-radius: 14px;
            z-index: 20;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06)
        }

        .pill {
            background: #0f1430;
            padding: 6px 10px;
            border-radius: 999px;
            opacity: .9
        }

        .btn {
            cursor: pointer;
            padding: 10px 14px;
            border-radius: 12px;
            background: var(--accent);
            color: #012321;
            font-weight: 800;
            border: none
        }

            .btn:disabled {
                opacity: .5;
                cursor: not-allowed
            }

        canvas {
            display: block;
            margin: 0 auto;
            background: #0b0e1a;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.04)
        }

        .overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5,8,20,.55);
            backdrop-filter: saturate(120%) blur(4px);
            z-index: 30
        }

        .card {
            width: min(900px,calc(100% - 24px));
            background: var(--panel);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,.5)
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        .grid {
            display: grid;
            gap: 12px
        }

        .kbd {
            font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
            background: #0b1026;
            padding: 2px 6px;
            border-radius: 6px
        }

        .label {
            font-size: .95rem;
            opacity: .85
        }

        .input {
            flex: 1;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.08);
            background: #0b1026;
            color: var(--ink);
        }

        .small {
            font-size: .9rem;
            opacity: .8
        }

        .hidden {
            display: none !important;
        }

        .host-pill {
            outline: 2px solid var(--accent);
        }

        .nameplate {
            font: 700 14px system-ui,sans-serif;
            text-align: center;
        }
    </style>
</head>

<body>
    <!-- HUD -->
    <div class="hud">
        <span class="pill">Våben: <b id="weapon">Pistol</b></span>
        <span class="pill">Ammo: <b id="ammo">∞</b></span>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Wave: <b id="wave">1</b></span>
        <span class="pill">HP: <b id="hp">100</b></span>
        <span class="pill" id="netpill">Net: <b id="role">—</b></span>
        <button id="restart" class="btn">Til menu</button>
    </div>

    <canvas id="game" width="1600" height="900"></canvas>

    <!-- HOVEDMENU -->
    <div class="overlay" id="menu">
        <div class="card grid">
            <h2 style="margin:0">Box Head</h2>

            <div class="grid">
                <div class="label">Dit navn (bruges i multiplayer):</div>
                <div class="row"><input id="nameInput" class="input" maxlength="20" placeholder="Fx: Hedef" /></div>
            </div>

            <div class="row">
                <button id="spBtn" class="btn">Singleplayer</button>
                <button id="mpToggle" class="btn">Multiplayer</button>
            </div>

            <div id="mpPanel" class="grid hidden" style="margin-top:6px">
                <div class="label">Vælg/skriv rum-navn:</div>
                <div class="row">
                    <input id="roomInput" class="input" maxlength="24" placeholder="Fx: venner-aften" />
                    <button id="joinBtn" class="btn" disabled>Join lobby</button>
                </div>
                <div class="small">Tip: Aftal et rum-navn med dine venner. Hver gruppe bruger sit eget.</div>
            </div>

            <div class="small">
                <div>Bevægelse: <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span> • Dash: <span class="kbd">Shift</span></div>
                <div>Sigte: mus • Skyd: venstre klik / <span class="kbd">Mellemrum</span> • Pause: <span class="kbd">P</span></div>
                <div>Våben: <span class="kbd">1</span> Pistol (∞), <span class="kbd">2</span> Shotgun, <span class="kbd">3</span> Riffel</div>
            </div>
        </div>
    </div>

    <!-- LOBBY -->
    <div class="overlay hidden" id="lobby">
        <div class="card grid">
            <h2 style="margin:0">Lobby – <span id="roomName">—</span></h2>
            <div>Rolle: <b id="lobbyRole">—</b></div>
            <div class="row">
                <div style="min-width:260px; max-height:240px; overflow:auto; background:#0b1026; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px;">
                    <div class="small" style="margin-bottom:6px">Spillere i rummet:</div>
                    <div id="lobbyList" class="grid"></div>
                </div>
                <div class="grid" style="min-width:240px">
                    <button id="startMatchBtn" class="btn hidden">Start spil (host)</button>
                    <div id="waitMsg" class="small">Venter på at host starter…</div>
                    <div id="inGameMsg" class="small hidden">Et spil er i gang – du venter til det er færdigt.</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script>
        'use strict';

        /* ------------ utils ------------ */
        const $ = (id) => document.getElementById(id);
        const show = id => $(id).classList.remove('hidden');
        const hide = id => $(id).classList.add('hidden');

        /* ------------ deterministic rng til skud ------------ */
        function h32(s) { let h = 2166136261 >>> 0; for (let i = 0; i < s.length; i++) { h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); } return h >>> 0; }
        function xs32(seed) { let x = seed >>> 0; return () => { x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return (x >>> 0) / 4294967296; }; }
        function detSym(id, uid, i) { return xs32((h32(id) ^ h32(uid) ^ (i * 0x9E3779B9)) >>> 0)() * 2 - 1; }

        /* ------------ NET (kun i multiplayer) ------------ */
        const NET = (() => {
            const HUB_URL = "https://www.hedef.dk/gamehub";
            const connection = new signalR.HubConnectionBuilder()
                .withUrl(HUB_URL, { withCredentials: false })
                .withAutomaticReconnect([0, 1000, 3000, 5000])
                .build();

            let myId = null, isHost = false, inGame = false, room = null;
            const others = new Map(); // id->{x,y,tx,ty,aim,weaponIndex}
            const names = new Map();

            function roleHud() {
                $('role').textContent = isHost ? 'Host' : 'Client';
                $('netpill').classList.toggle('host-pill', isHost);
                $('lobbyRole').textContent = isHost ? 'Host' : 'Client';
                $('startMatchBtn').classList.toggle('hidden', !isHost);
            }
            function renderLobby() {
                $('roomName').textContent = room || '—';
                const list = $('lobbyList'); list.innerHTML = '';
                // Med dig selv øverst
                const ids = new Set();
                if (myId) ids.add(myId);
                for (const id of others.keys()) ids.add(id);
                for (const id of ids) {
                    const div = document.createElement('div');
                    div.className = 'nameplate';
                    div.textContent = names.get(id) || ('Spiller ' + (id || '').slice(-4));
                    list.appendChild(div);
                }
                $('inGameMsg').classList.toggle('hidden', !inGame);
                $('waitMsg').classList.toggle('hidden', inGame);
            }

            function setRoom(r) { room = r; }

            async function connectAndJoin(r, playerName) {
                room = r;
                // handlers
                connection.on("Welcome", id => { myId = id; });
                connection.on("Roster", ids => {
                    // host = laveste id i rummet
                    const arr = Array.from(ids || []);
                    if (myId && !arr.includes(myId)) arr.push(myId);
                    arr.sort();
                    const newIsHost = (arr[0] === myId);
                    if (newIsHost !== isHost) { isHost = newIsHost; roleHud(); }
                    renderLobby();
                });
                connection.on("PlayerJoined", id => { others.set(id, { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0 }); renderLobby(); });
                connection.on("PlayerLeft", id => { others.delete(id); names.delete(id); renderLobby(); });

                connection.on("NamesSnapshot", dict => { names.clear(); for (const k in dict) names.set(k, dict[k]); renderLobby(); });
                connection.on("PlayerNamed", (id, name) => { names.set(id, name); renderLobby(); });

                connection.on("GameState", state => { inGame = !!state; renderLobby(); });
                connection.on("GameStarted", () => {
                    inGame = true; hide('lobby');
                    if (isHost && State.obstacles.length === 0) {
                        MapGen.makeOpenArena();
                        sendObstaclesSnapshot(State.obstacles.map(o => ({ x: o.x, y: o.y, w: o.w, h: o.h })));
                        Game._sentObstacles = true;
                    }
                    Game.startMatch('mp');
                });
                connection.on("GameEnded", () => { inGame = false; Game.endToLobby(); show('lobby'); renderLobby(); });

                connection.on("State", (id, ps) => {
                    if (id === myId) return;
                    let o = others.get(id);
                    if (!o) { o = { x: ps.x, y: ps.y, tx: ps.x, ty: ps.y, aim: ps.aim || 0, weaponIndex: 0 }; others.set(id, o); }
                    o.tx = ps.x; o.ty = ps.y; o.aim = ps.aim || 0;
                });
                connection.on("WeaponChanged", (id, idx) => {
                    if (id === myId) return;
                    const o = others.get(id) || { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0 };
                    o.weaponIndex = idx | 0; others.set(id, o);
                });

                connection.on("Enemies", list => { if (!isHost) applyEnemies(list); });
                connection.on("Obstacles", list => { if (!isHost) applyObstacles(list); });

                connection.on("ShootRequest", (shooterId, payload) => {
                    if (!isHost) return;
                    if (ShotCache.has(payload.uid)) return;
                    ShotCache.add(payload.uid);
                    connection.invoke("ShootEvent", room, shooterId, payload).catch(() => { });
                    spawnShot(shooterId, payload, State.bullets);
                });
                connection.on("ShootEvent", (shooterId, payload) => {
                    if (ShotCache.has(payload.uid)) return;
                    ShotCache.add(payload.uid);
                    const target = isHost ? State.bullets : Remote.bullets;
                    spawnShot(shooterId, payload, target);
                });

                await connection.start();
                await connection.invoke("Join", room);
                await connection.invoke("SetName", room, playerName);
                roleHud(); renderLobby();
                hide('menu'); show('lobby');
            }

            function setName(n) { if (!room) return; names.set(myId, n); connection.invoke("SetName", room, n).catch(() => { }); }
            function startGame() { if (!room) return; connection.invoke("StartGame", room).catch(() => { }); }
            function endGame() { if (!room) return; connection.invoke("EndGame", room).catch(() => { }); }

            function sendState() {
                if (!room) return;
                const p = State.player;
                connection.invoke("UpdateSelf", {
                    Room: room, X: p.x, Y: p.y, VX: p.vx, VY: p.vy, Aim: State.aim || 0, ClientTs: performance.now() | 0
                }).catch(() => { });
            }
            function sendEnemiesSnapshot(list) { if (isHost && room) connection.invoke("EnemiesSnapshot", room, list).catch(() => { }); }
            function sendObstaclesSnapshot(list) { if (isHost && room) connection.invoke("ObstaclesSnapshot", room, list).catch(() => { }); }
            function sendWeaponChanged(idx) { if (room) connection.invoke("WeaponChanged", room, idx | 0).catch(() => { }); }
            function sendShootRequest(payload) { if (room) connection.invoke("ShootRequest", room, payload).catch(() => { }); }
            function sendShootEvent(shooterId, payload) { if (room) connection.invoke("ShootEvent", room, shooterId, payload).catch(() => { }); }

            function getOthers() { return others; }
            function getIsHost() { return isHost; }
            function getMyId() { return myId; }
            function getName(id) { return names.get(id) || ""; }
            function getRoom() { return room; }

            return { setRoom, connectAndJoin, setName, startGame, endGame, sendState, sendEnemiesSnapshot, sendObstaclesSnapshot, sendWeaponChanged, sendShootRequest, sendShootEvent, getOthers, getIsHost, getMyId, getName, getRoom };
        })();

        /* ------------ game state ------------ */
        const canvas = $('game'); const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        const Config = Object.freeze({
            bounds: { x: 60, y: 60, w: W - 120, h: H - 120 },
            friction: 0.86,
            dash: { cool: 900, speed: 7 },
            player: { speed: 0.5, size: 22, hp: 100 },
            spawn: { perWaveBase: 6, perWaveScale: 1.1, maxBatch: 22 },
            pickups: { max: 3, spawnMin: 20000, spawnMax: 30000 },
            fixedDt: 1000 / 60
        });

        const Weapons = [
            { key: '1', name: 'Pistol', dmg: 20, speed: 10, cd: 500, spread: 0.02, pellets: 1, pierce: 0, life: 900, ammoCost: 0, pickup: 0 },
            { key: '2', name: 'Shotgun', dmg: 14, speed: 9, cd: 600, spread: 0.18, pellets: 8, pierce: 0, life: 500, ammoCost: 1, pickup: 40 },
            { key: '3', name: 'Riffel', dmg: 22, speed: 14, cd: 90, spread: 0.01, pellets: 1, pierce: 0, life: 1100, ammoCost: 1, pickup: 120 }
        ];

        const Save = {
            get highScore() { return parseInt(localStorage.getItem('boxhead_highscore')) || 0; },
            set highScore(v) { localStorage.setItem('boxhead_highscore', String(v | 0)); }
        };

        const hud = { weapon: $('weapon'), ammo: $('ammo'), score: $('score'), wave: $('wave'), hp: $('hp') };

        const MathX = { rand(a, b) { return Math.random() * (b - a) + a; }, clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }, norm(x, y) { const l = Math.hypot(x, y) || 1; return [x / l, y / l]; } };

        const Input = (() => {
            const keys = new Set(); const mouse = { x: W / 2, y: H / 2, down: false };
            window.addEventListener('keydown', e => {
                if (e.code === 'KeyP') { Game.paused = !Game.paused; return; }
                if (e.code === 'Space') { mouse.down = true; }
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') Systems.tryDash();
                keys.add(e.code); Systems.handleWeaponKeys(e.code);
            });
            window.addEventListener('keyup', e => { if (e.code === 'Space') mouse.down = false; keys.delete(e.code); });
            canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width / r.width); mouse.y = (e.clientY - r.top) * (canvas.height / r.height); });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            canvas.addEventListener('mouseup', () => mouse.down = false);
            return { keys, mouse };
        })();

        const State = (() => {
            const player = { x: W / 2, y: H / 2, vx: 0, vy: 0, size: Config.player.size, speed: Config.player.speed, hp: Config.player.hp, alive: true };
            const bullets = [], enemies = [], particles = [], obstacles = [], pickups = [];
            let weaponIndex = 0; const ammo = { 1: Infinity, 2: 0, 3: 0 };
            let score = 0, wave = 1, spawnTimer = 0, pickupTimer = 0, lastFire = -1e9;
            let highScore = Save.highScore; let myName = ''; let aim = 0;
            return { player, bullets, enemies, particles, obstacles, pickups, weaponIndex, ammo, score, wave, spawnTimer, pickupTimer, lastFire, highScore, myName, aim };
        })();

        const Remote = { bullets: [] };
        const ShotCache = new Set();

        /* ------------ UI (menu/lobby) ------------ */
        function toMenu() {
            show('menu'); hide('lobby');
            $('roomInput').value = '';
            $('joinBtn').disabled = true;
        }
        function toLobby() { hide('menu'); show('lobby'); }

        $('mpToggle').onclick = () => $('mpPanel').classList.toggle('hidden');
        $('roomInput').oninput = () => $('joinBtn').disabled = !$('roomInput').value.trim();
        $('restart').onclick = () => { Game.endToMenu(); };

        $('spBtn').onclick = () => {
            const nm = $('nameInput').value.trim().slice(0, 20); State.myName = nm || 'Spiller';
            hide('menu'); Game.startMatch('sp'); // fuldt offline
        };

        $('joinBtn').onclick = async () => {
            const nm = $('nameInput').value.trim().slice(0, 20) || 'Spiller';
            const room = $('roomInput').value.trim().toLowerCase().replace(/[^a-z0-9\-_.]/g, '-').slice(0, 24);
            if (!room) return;
            State.myName = nm;
            await NET.connectAndJoin(room, nm);
        };

        $('startMatchBtn').onclick = () => NET.startGame();

        /* ------------ HUD ------------ */
        function HUDupdate() {
            const w = Weapons[State.weaponIndex];
            hud.weapon.textContent = w.name;
            const a = State.ammo[State.weaponIndex + 1];
            hud.ammo.textContent = (a === Infinity) ? '∞' : String(a | 0);
            hud.score.textContent = State.score;
            hud.wave.textContent = State.wave;
            hud.hp.textContent = Math.max(0, Math.ceil(State.player.hp));
        }

        /* ------------ Map ------------ */
        const MapGen = {
            makeOpenArena() {
                State.obstacles.length = 0;
                const b = Config.bounds; const n = Math.floor(MathX.rand(10, 21));
                for (let i = 0; i < n; i++) {
                    const w = MathX.rand(60, 120), h = MathX.rand(60, 120);
                    const x = MathX.rand(b.x + 20, b.x + b.w - w - 20);
                    const y = MathX.rand(b.y + 20, b.y + b.h - h - 20);
                    const startSafe = { x: W / 2 - 200, y: H / 2 - 200, w: 400, h: 400 };
                    if (x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y) { i--; continue; }
                    State.obstacles.push({ x, y, w, h });
                }
            }
        };
        function applyEnemies(list) { State.enemies.length = 0; for (const e of list) State.enemies.push({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color, vx: 0, vy: 0 }); }
        function applyObstacles(list) { State.obstacles.length = 0; for (const o of list) State.obstacles.push({ x: o.x, y: o.y, w: o.w, h: o.h }); }

        /* ------------ Systems ------------ */
        const Systems = {
            handleWeaponKeys(code) { const map = { Digit1: 0, Digit2: 1, Digit3: 2 }; if (code in map) { State.weaponIndex = map[code]; if (Game.mode === 'mp') NET.sendWeaponChanged(State.weaponIndex); HUDupdate(); } },
            tryDash() {
                const now = performance.now(); if (!Systems._dashLast) Systems._dashLast = -9999;
                if (now - Systems._dashLast < Config.dash.cool) return;
                let dx = 0, dy = 0; const k = Input.keys;
                if (k.has('KeyW')) dy -= 1; if (k.has('KeyS')) dy += 1; if (k.has('KeyA')) dx -= 1; if (k.has('KeyD')) dx += 1;
                if (!dx && !dy) return; const [nx, ny] = MathX.norm(dx, dy);
                State.player.vx += nx * Config.dash.speed; State.player.vy += ny * Config.dash.speed;
                Systems.puff(State.player.x, State.player.y, 14, 4, 300, 'rgba(77,226,204,.75)'); Systems._dashLast = now;
            },
            shoot() {
                const w = Weapons[State.weaponIndex]; const now = performance.now(); if (now - State.lastFire < w.cd) return;
                if (w.ammoCost > 0) { const slot = State.weaponIndex + 1; if (!State.ammo[slot] || State.ammo[slot] <= 0) { State.lastFire = now; return; } State.ammo[slot] -= w.ammoCost; }
                State.lastFire = now;

                const uid = (Game.mode === 'mp' ? (NET.getMyId() || 'me') : 'sp') + ':' + (now | 0) + ':' + State.weaponIndex;
                const payload = { x: State.player.x, y: State.player.y, angle: State.aim, weaponIndex: State.weaponIndex, ts: now | 0, uid };

                if (Game.mode === 'mp') {
                    if (NET.getIsHost()) {
                        NET.sendShootEvent(NET.getMyId() || "", payload);
                        if (!ShotCache.has(uid)) { ShotCache.add(uid); spawnShot(NET.getMyId() || "", payload, State.bullets); }
                    } else {
                        NET.sendShootRequest(payload);
                    }
                } else {
                    spawnShot('sp', payload, Remote.bullets);  // SP lokalt
                }
                HUDupdate();
            },
            movePlayer(dt) {
                let ax = 0, ay = 0; const k = Input.keys;
                if (k.has('KeyW')) ay -= 1; if (k.has('KeyS')) ay += 1; if (k.has('KeyA')) ax -= 1; if (k.has('KeyD')) ax += 1;
                if (ax || ay) { const [nx, ny] = MathX.norm(ax, ay); State.player.vx += nx * State.player.speed; State.player.vy += ny * State.player.speed; }
                State.player.vx *= Config.friction; State.player.vy *= Config.friction;
                State.player.x += State.player.vx; State.player.y += State.player.vy;
                Systems.resolveAABB(State.player, State.player.size);
            },
            moveBullets(dt, list) {
                for (let i = list.length - 1; i >= 0; i--) {
                    const b = list[i]; b.x += b.vx; b.y += b.vy; b.life -= dt;
                    let hit = false; for (const o of State.obstacles) { if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) { hit = true; break; } }
                    if (hit) { Systems.puff(b.x, b.y, 6, 1.1, 200, 'rgba(230,236,243,.6)'); list.splice(i, 1); continue; }
                    if (b.x < -50 || b.y < -50 || b.x > W + 50 || b.y > H + 50 || b.life <= 0) list.splice(i, 1);
                }
            },
            // VÆLG NÆRMESTE SPILLER (host tager alle med; SP kun dig selv)
            moveEnemies(dt) {
                // saml mulige mål
                const targets = [{ x: State.player.x, y: State.player.y }];
                if (Game.mode === 'mp') {
                    for (const [, o] of NET.getOthers()) { targets.push({ x: o.tx ?? o.x, y: o.ty ?? o.y }); }
                }
                for (const e of State.enemies) {
                    // find nærmeste target
                    let tx = targets[0].x, ty = targets[0].y, best = Infinity;
                    for (const t of targets) {
                        const d2 = (t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y);
                        if (d2 < best) { best = d2; tx = t.x; ty = t.y; }
                    }
                    const dx = tx - e.x, dy = ty - e.y, d = Math.hypot(dx, dy) + 1e-4;
                    const s = e.spd * (1 + Math.min(0.6, 30 / d));
                    e.vx = (dx / d) * s; e.vy = (dy / d) * s; e.x += e.vx; e.y += e.vy;
                    Systems.resolveAABB(e, e.size);
                }
            },
            resolveAABB(ent, size) {
                const b = Config.bounds;
                ent.x = MathX.clamp(ent.x, b.x + size / 2, b.x + b.w - size / 2);
                ent.y = MathX.clamp(ent.y, b.y + size / 2, b.y + b.h - size / 2);
                for (const o of State.obstacles) {
                    const ex = ent.x - size / 2, ey = ent.y - size / 2, ew = size, eh = size;
                    if (ex < o.x + o.w && ex + ew > o.x && ey < o.y + o.h && ey + eh > o.y) {
                        const dx1 = (o.x + o.w) - ex, dx2 = (ex + ew) - o.x, dy1 = (o.y + o.h) - ey, dy2 = (ey + eh) - o.y;
                        const m = Math.min(dx1, dx2, dy1, dy2);
                        if (m === dx1) ent.x = o.x + o.w + size / 2;
                        else if (m === dx2) ent.x = o.x - size / 2;
                        else if (m === dy1) ent.y = o.y + o.h + size / 2;
                        else ent.y = o.y - size / 2;
                    }
                }
            },
            damageOnTouch(dt) {
                for (const e of State.enemies) {
                    if (Math.hypot(State.player.x - e.x, State.player.y - e.y) < e.size + State.player.size - 6) {
                        State.player.hp -= 10 * dt / 1000;
                        if (State.player.hp <= 0) { Game.onLocalDeath(); return; }
                        if (Math.random() < 0.2) Systems.blood(State.player.x, State.player.y);
                    }
                }
            },
            bulletsVsEnemies(list) {
                for (let i = State.enemies.length - 1; i >= 0; i--) {
                    const e = State.enemies[i];
                    for (let j = list.length - 1; j >= 0; j--) {
                        const b = list[j];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                            e.hp -= (b.damage || 20);
                            if (e.hp <= 0) { Systems.puff(e.x, e.y, 18, 2.4, 500, 'rgba(255,107,107,.9)'); State.enemies.splice(i, 1); State.score += 10; }
                            if (b.pierce && b.pierce > 0) { b.pierce--; Systems.blood(e.x, e.y); }
                            else { list.splice(j, 1); Systems.blood(e.x, e.y); }
                            break;
                        }
                    }
                }
            },
            spawnPickup() {
                const options = [2, 3, 3]; const type = options[Math.floor(Math.random() * options.length)];
                const b = Config.bounds; const w = 28, h = 28;
                for (let tries = 0; tries < 50; tries++) {
                    const x = MathX.rand(b.x + 20, b.x + b.w - w - 20), y = MathX.rand(b.y + 20, b.y + b.h - h - 20);
                    const startSafe = { x: W / 2 - 160, y: H / 2 - 160, w: 320, h: 320 };
                    let bad = x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y;
                    for (const o of State.obstacles) { if (x < o.x + o.w && x + w > o.x && y < o.y + o.h && y + h > o.y) { bad = true; break; } }
                    if (!bad) { State.pickups.push({ x, y, w, h, type }); break; }
                }
            },
            tryPickup() {
                for (let i = State.pickups.length - 1; i >= 0; i--) {
                    const p = State.pickups[i];
                    if (State.player.x > p.x && State.player.x < p.x + p.w && State.player.y > p.y && State.player.y < p.y + p.h) {
                        const w = Weapons[p.type - 1]; State.ammo[p.type] = (State.ammo[p.type] || 0) + w.pickup; State.pickups.splice(i, 1); HUDupdate();
                    }
                }
            },
            spawnEnemy() {
                const edge = Math.floor(MathX.rand(0, 4)); let x, y;
                if (edge === 0) { x = MathX.rand(0, W); y = -20; }
                if (edge === 1) { x = W + 20; y = MathX.rand(0, H); }
                if (edge === 2) { x = MathX.rand(0, W); y = H + 20; }
                if (edge === 3) { x = -20; y = MathX.rand(0, H); }
                const r = Math.random(); let type, size, hp, spd, color;
                if (r < 0.75) { type = 'normal'; size = MathX.rand(16, 24); hp = 10 + State.wave * 2 + MathX.rand(-2, 2); spd = 0.55 + Math.min(1.2, State.wave * 0.05) + MathX.rand(-0.08, 0.08); color = '#ff6b6b'; }
                else { type = 'big'; size = MathX.rand(36, 44); hp = 150 + State.wave * 6 + MathX.rand(-4, 4); spd = 0.35 + Math.min(0.7, State.wave * 0.03) + MathX.rand(-0.05, 0.05); color = '#ff9f43'; }
                State.enemies.push({ x, y, vx: 0, vy: 0, size, hp, spd, type, color });
            },
            nextWave() { State.wave++; for (let i = 0; i < Math.min(Config.spawn.perWaveBase + State.wave * Config.spawn.perWaveScale, Config.spawn.maxBatch); i++) Systems.spawnEnemy(); State.player.hp = MathX.clamp(State.player.hp + 12, 0, 100); Systems.flash('#4de2cc'); },
            puff(x, y, n = 12, speed = 3, life = 500, c = 'rgba(255,255,255,.8)') { for (let i = 0; i < n; i++) { const a = MathX.rand(0, Math.PI * 2), v = MathX.rand(0.5, speed); State.particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life, c }); } },
            blood(x, y) { Systems.puff(x, y, 16, 2.6, 700, 'rgba(255,80,80,.8)'); },
            flash(color) { State.particles.push({ x: W / 2, y: H / 2, vx: 0, vy: 0, life: 160, c: color, full: true }); },
            updateParticles(dt) { for (let i = State.particles.length - 1; i >= 0; i--) { const p = State.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= dt; if (p.life <= 0) State.particles.splice(i, 1); } }
        };

        function spawnShot(shooterId, payload, list) {
            const w = Weapons[payload.weaponIndex]; const base = payload.angle;
            for (let i = 0; i < w.pellets; i++) {
                const ang = base + w.spread * detSym(shooterId, payload.uid, i);
                const vx = Math.cos(ang) * w.speed, vy = Math.sin(ang) * w.speed;
                list.push({ x: payload.x + Math.cos(base) * (State.player.size + 8), y: payload.y + Math.sin(base) * (State.player.size + 8), vx, vy, life: w.life, damage: w.dmg, pierce: w.pierce });
            }
            Systems.puff(payload.x + Math.cos(base) * 14, payload.y + Math.sin(base) * 14, 6 + w.pellets, 1.2, 160, 'rgba(255,255,255,.5)');
        }

        /* ------------ render ------------ */
        const Render = {
            draw() {
                const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, W, H);
                const b = Config.bounds;

                // bg + grid
                ctx.save(); ctx.fillStyle = '#0a0e1b'; ctx.fillRect(0, 0, W, H);
                ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = 2; ctx.strokeRect(b.x - 10, b.y - 10, b.w + 20, b.h + 20);
                ctx.globalAlpha = .06;
                for (let x = b.x; x < b.x + b.w; x += 40) { ctx.beginPath(); ctx.moveTo(x, b.y); ctx.lineTo(x, b.y + b.h); ctx.stroke(); }
                for (let y = b.y; y < b.y + b.h; y += 40) { ctx.beginPath(); ctx.moveTo(b.x, y); ctx.lineTo(b.x + b.w, y); ctx.stroke(); }
                ctx.globalAlpha = 1; ctx.restore();

                // crates
                ctx.save(); for (const o of State.obstacles) { ctx.fillStyle = '#1e243f'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.strokeRect(o.x + .5, o.y + .5, o.w - 1, o.h - 1); } ctx.restore();

                // pickups
                ctx.save(); for (const p of State.pickups) { let col = '#ffb84d'; if (p.type === 3) col = '#4da6ff'; ctx.fillStyle = col; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.strokeRect(p.x + .5, p.y + .5, p.w - 1, p.h - 1); } ctx.restore();

                // particles
                for (const p of State.particles) {
                    if (p.full) { const t = MathX.clamp(p.life / 160, 0, 1); ctx.save(); ctx.globalAlpha = t * .25; ctx.fillStyle = p.c; ctx.fillRect(0, 0, W, H); ctx.restore(); }
                    else { ctx.save(); ctx.globalAlpha = MathX.clamp(p.life / 500, 0, 1); ctx.fillStyle = p.c; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); ctx.restore(); }
                }

                // tegn spiller (uden “streg/barrel”)
                function drawPlayer(x, y, aim, isSelf, name) {
                    const s = 22, head = 12;
                    ctx.save(); ctx.translate(x, y); ctx.rotate(aim || 0);
                    ctx.fillStyle = isSelf ? '#1b2a57' : '#2a335f';
                    ctx.fillRect(-s / 2, -s / 2, s, s);
                    ctx.fillStyle = isSelf ? '#4de2cc' : '#9aa7ff';
                    ctx.fillRect(s / 2 - 2, -head / 2, head, head);
                    ctx.restore();

                    if (name) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(0,0,0,.45)'; ctx.fillRect(x - 60, y - 38, 120, 22);
                        ctx.fillStyle = '#e7ecf3'; ctx.font = '700 14px system-ui,sans-serif'; ctx.textAlign = 'center';
                        ctx.fillText(name, x, y - 22);
                        ctx.restore();
                    }
                }

                // lokal
                drawPlayer(State.player.x, State.player.y, State.aim, true, State.myName);

                // andre
                if (Game.mode === 'mp') {
                    for (const [id, o] of NET.getOthers()) {
                        drawPlayer(o.x, o.y, o.aim || 0, false, NET.getName(id));
                    }
                }

                // enemies
                for (const e of State.enemies) {
                    ctx.save(); ctx.translate(e.x, e.y); ctx.fillStyle = e.color || '#ff6b6b';
                    ctx.fillRect(-e.size / 2, -e.size / 2, e.size, e.size);
                    ctx.fillStyle = '#10131f'; ctx.fillRect(-4, -4, 3, 3); ctx.fillRect(1, -4, 3, 3);
                    ctx.restore();
                }

                // bullets
                ctx.save(); ctx.fillStyle = '#e7ecf3';
                const bl = (Game.mode === 'mp' ? (NET.getIsHost() ? State.bullets : Remote.bullets) : Remote.bullets);
                for (const b of bl) ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
                ctx.restore();
            }
        };

        /* ------------ game ------------ */
        const Game = {
            mode: 'sp', running: false, paused: false, _loop: 0, _sentObstacles: false,

            startMatch(mode) {
                this.mode = mode; this.running = true; this.paused = false;
                // init state
                State.enemies.length = 0; State.bullets.length = 0; Remote.bullets.length = 0;
                State.particles.length = 0; State.pickups.length = 0;
                State.player.x = W / 2; State.player.y = H / 2; State.player.vx = 0; State.player.vy = 0; State.player.hp = Config.player.hp; State.player.alive = true;
                State.weaponIndex = 0; State.ammo[2] = 0; State.ammo[3] = 0;
                State.score = 0; State.wave = 1; State.spawnTimer = 0; State.pickupTimer = 0; State.lastFire = -1e9;

                if (mode === 'sp') { MapGen.makeOpenArena(); }

                // gameloop
                let last = performance.now(), acc = 0, dt = Config.fixedDt;
                const loop = (ts) => {
                    if (!this.running) return;
                    const frame = ts - last; last = ts;
                    if (!this.paused) {
                        acc = Math.min(acc + frame, 250);
                        while (acc >= dt) { this.update(dt); acc -= dt; }
                        Render.draw(); HUDupdate();
                    }
                    this._loop = requestAnimationFrame(loop);
                };
                cancelAnimationFrame(this._loop);
                this._loop = requestAnimationFrame(loop);

                // net tick 20Hz (kun MP, host udsender)
                if (mode === 'mp') {
                    const tick = () => {
                        if (!this.running) return;
                        if (NET.getIsHost()) {
                            const es = State.enemies.map(e => ({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color }));
                            NET.sendEnemiesSnapshot(es);
                            if (!this._sentObstacles && State.obstacles.length > 0) {
                                NET.sendObstaclesSnapshot(State.obstacles.map(o => ({ x: o.x, y: o.y, w: o.w, h: o.h })));
                                this._sentObstacles = true;
                            }
                        }
                        setTimeout(tick, 50);
                    };
                    tick();
                }
            },

            update(dt) {
                // sigte
                const dx = Input.mouse.x - State.player.x, dy = Input.mouse.y - State.player.y;
                State.aim = Math.atan2(dy, dx);

                if (Input.mouse.down) Systems.shoot();
                Systems.movePlayer(dt);

                if (this.mode === 'mp') {
                    if (NET.getIsHost()) {
                        Systems.moveEnemies(dt);
                        Systems.damageOnTouch(dt);
                        Systems.bulletsVsEnemies(State.bullets);
                        Systems.moveBullets(dt, State.bullets);
                        // spawns/waves kun host
                        State.spawnTimer -= dt; State.pickupTimer -= dt;
                        if (State.spawnTimer <= 0) { const perSec = Math.min(0.5 + State.wave * 0.18, 2.0); State.spawnTimer = 1000 / perSec; Systems.spawnEnemy(); }
                        if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) { State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax); Systems.spawnPickup(); }
                        if (State.score > State.wave * 150) Systems.nextWave();
                    } else {
                        Systems.moveBullets(dt, Remote.bullets); // visuelle kugler for clients
                    }
                    NET.sendState();
                    // smooth others
                    for (const [, o] of NET.getOthers()) { const s = 0.18; o.x += (o.tx - o.x) * s; o.y += (o.ty - o.y) * s; }
                } else {
                    // singleplayer fuld sim lokalt
                    Systems.moveEnemies(dt);
                    Systems.damageOnTouch(dt);
                    Systems.bulletsVsEnemies(Remote.bullets);
                    Systems.moveBullets(dt, Remote.bullets);
                    State.spawnTimer -= dt; State.pickupTimer -= dt;
                    if (State.spawnTimer <= 0) { const perSec = Math.min(0.5 + State.wave * 0.18, 2.0); State.spawnTimer = 1000 / perSec; Systems.spawnEnemy(); }
                    if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) { State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax); Systems.spawnPickup(); }
                    if (State.score > State.wave * 150) Systems.nextWave();
                }
            },

            onLocalDeath() {
                State.player.alive = false;
                if (this.mode === 'mp') {
                    // simpelt: når host dør ⇒ slut for alle (kan udvides til “alle døde”)
                    if (NET.getIsHost()) NET.endGame();
                } else {
                    this.endToMenu();
                }
            },

            endToLobby() {
                this.running = false; this.paused = false;
                show('lobby');
            },

            endToMenu() {
                this.running = false; this.paused = false;
                toMenu();
            }
        };

        // initial: vis menu
        toMenu();
    </script>
</body>
</html>
