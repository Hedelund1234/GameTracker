<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Box Head – Mini Shooter</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #161a2e;
            --ink: #e7ecf3;
            --accent: #4de2cc;
        }

        html, body {
            margin: 0;
            height: 100%;
            background: radial-gradient(1200px 800px at 30% 20%, #1a1e36, var(--bg));
            color: var(--ink);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            background: color-mix(in oklab, var(--panel) 90%, black);
            padding: 10px 14px;
            border-radius: 14px;
            z-index: 20;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06)
        }

        .pill {
            background: #0f1430;
            padding: 6px 10px;
            border-radius: 999px;
            opacity: .9
        }

        .btn {
            cursor: pointer;
            padding: 10px 14px;
            border-radius: 12px;
            background: var(--accent);
            color: #012321;
            font-weight: 800;
            border: none
        }

            .btn:disabled {
                opacity: .5;
                cursor: not-allowed
            }

        canvas {
            display: block;
            margin: 0 auto;
            background: #0b0e1a;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.04)
        }

        .overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5,8,20,.55);
            backdrop-filter: saturate(120%) blur(4px);
            z-index: 30
        }

        .card {
            width: min(980px,calc(100% - 24px));
            background: var(--panel);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,.5)
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        .grid {
            display: grid;
            gap: 12px
        }

        .kbd {
            font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
            background: #0b1026;
            padding: 2px 6px;
            border-radius: 6px
        }

        .label {
            font-size: .95rem;
            opacity: .85
        }

        .input {
            flex: 1;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.08);
            background: #0b1026;
            color: var(--ink);
        }

        .small {
            font-size: .9rem;
            opacity: .8
        }

        .hidden {
            display: none !important;
        }

        .host-pill {
            outline: 2px solid var(--accent);
        }

        .nameplate {
            font: 700 14px system-ui,sans-serif;
            text-align: left;
        }

        .roomrow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-radius: 10px;
            background: #0b1026;
            border: 1px solid rgba(255,255,255,.06);
            margin-bottom: 8px
        }

            .roomrow.ingame {
                opacity: .6
            }

        .badge {
            font: 700 12px system-ui;
            padding: 2px 8px;
            border-radius: 999px;
            background: #0f1430
        }
    </style>
</head>

<body>
    <!-- HUD -->
    <div class="hud">
        <span class="pill">Våben: <b id="weapon">Pistol</b></span>
        <span class="pill">Ammo: <b id="ammo">∞</b></span>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Wave: <b id="wave">1</b></span>
        <span class="pill">HP: <b id="hp">100</b></span>
        <span class="pill" id="netpill">Net: <b id="role">—</b></span>
        <button id="restart" class="btn">Til menu</button>
    </div>

    <canvas id="game" width="1600" height="900"></canvas>

    <!-- MENU -->
    <div class="overlay" id="menu">
        <div class="card grid">
            <h2 style="margin:0">Box Head</h2>

            <div class="grid">
                <div class="label">Dit navn (bruges i multiplayer):</div>
                <div class="row"><input id="nameInput" class="input" maxlength="20" placeholder="Fx: Hedef" /></div>
            </div>

            <div class="row">
                <button id="spBtn" class="btn">Singleplayer</button>
                <button id="mpToggle" class="btn">Multiplayer</button>
            </div>

            <div id="mpPanel" class="grid hidden" style="margin-top:6px">
                <div class="label">Vælg/skriv rum-navn:</div>
                <div class="row">
                    <input id="roomInput" class="input" maxlength="24" placeholder="Fx: venner-aften" />
                    <button id="joinBtn" class="btn" disabled>Join lobby</button>
                </div>
                <div class="small">Tip: Aftal et rum-navn med dine venner. Hver gruppe bruger sit eget.</div>
                <div class="grid" style="margin-top:8px">
                    <div class="label">Aktive rum:</div>
                    <div id="roomsList"></div>
                    <div class="row">
                        <button id="refreshRooms" class="btn">Opdater rumliste</button>
                    </div>
                    <div id="joinError" class="small hidden" style="color:#ff9f9f">Rummet er i gang – vælg et andet eller vent.</div>
                </div>
            </div>

            <div class="small">
                <div>Bevægelse: <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span> • Dash: <span class="kbd">Shift</span></div>
                <div>Sigte: mus • Skyd: venstre klik / <span class="kbd">Mellemrum</span> • Pause: <span class="kbd">P</span></div>
                <div>Våben: <span class="kbd">1</span> Pistol (∞), <span class="kbd">2</span> Shotgun, <span class="kbd">3</span> Riffel</div>
            </div>
        </div>
    </div>

    <!-- LOBBY -->
    <div class="overlay hidden" id="lobby">
        <div class="card grid">
            <h2 style="margin:0">Lobby – <span id="roomName">—</span></h2>
            <div>Rolle: <b id="lobbyRole">—</b></div>
            <div>Sidste score: <b id="lastScore">0</b></div>
            <div class="row">
                <div style="min-width:260px; max-height:240px; overflow:auto; background:#0b1026; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px; flex:1">
                    <div class="small" style="margin-bottom:6px">Spillere i rummet:</div>
                    <div id="lobbyList" class="grid"></div>
                </div>
                <div class="grid" style="min-width:240px">
                    <button id="startMatchBtn" class="btn hidden">Start spil (host)</button>
                    <div id="waitMsg" class="small">Venter på at host starter…</div>

                    <button id="lobbyBackBtn" class="btn">Tilbage</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script>
        'use strict';

        /* ------------ utils ------------ */
        const $ = (id) => document.getElementById(id);
        const show = id => $(id).classList.remove('hidden');
        const hide = id => $(id).classList.add('hidden');

        /* ------------ deterministic rng til skud ------------ */
        function h32(s) { let h = 2166136261 >>> 0; for (let i = 0; i < s.length; i++) { h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); } return h >>> 0; }
        function xs32(seed) { let x = seed >>> 0; return () => { x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return (x >>> 0) / 4294967296; }; }
        function detSym(id, uid, i) { return xs32((h32(id) ^ h32(uid) ^ (i * 0x9E3779B9)) >>> 0)() * 2 - 1; }

        /* ------------ NET (bruges kun i MP) ------------ */
        const NET = (() => {
            const HUB_URL = "https://www.hedef.dk/gamehub";
            const connection = new signalR.HubConnectionBuilder()
                .withUrl(HUB_URL, { withCredentials: false })
                .withAutomaticReconnect([0, 1000, 3000, 5000])
                .build();

            let myId = null, isHost = false, inGame = false, room = null, connected = false, leaderId = null;
            const others = new Map();
            const names = new Map();

            // --- UI helpers ---
            function roleHud() {
                const amIHost = (leaderId && myId) ? (leaderId === myId) : isHost;
                isHost = amIHost;
                $('role').textContent = isHost ? 'Host' : 'Client';
                $('netpill').classList.toggle('host-pill', isHost);
                $('lobbyRole').textContent = isHost ? 'Host' : 'Client';
                $('startMatchBtn').classList.toggle('hidden', !isHost);
            }
            function renderLobby() {
                $('roomName').textContent = room || '—';
                const list = $('lobbyList'); list.innerHTML = '';
                const ids = new Set(); if (myId) ids.add(myId); for (const id of others.keys()) ids.add(id);
                for (const id of ids) {
                    const div = document.createElement('div');
                    div.className = 'nameplate';
                    const crown = (id === leaderId) ? ' 👑' : '';
                    const dead = (id === myId ? !State.player.alive : (others.get(id)?.dead)) ? ' (død)' : '';
                    div.textContent = (names.get(id) || ('Spiller ' + (id || '').slice(-4))) + crown + dead;
                    list.appendChild(div);
                }
            }

            // --- Rooms list (menu) ---
            function renderRoomsList(snapshot) {
                const box = $('roomsList'); if (!box) return; box.innerHTML = '';
                snapshot.forEach(r => {
                    const row = document.createElement('div');
                    row.className = 'roomrow' + (r.inGame ? ' ingame' : '');
                    row.innerHTML = `
                            <div><b>${r.name}</b><div class="small">${r.count} spiller(e)</div></div>
                            <div class="badge">${r.inGame ? 'I gang' : 'Åben'}</div>
                        `;
                    if (!r.inGame) {
                        row.style.cursor = 'pointer';
                        row.onclick = () => { $('roomInput').value = r.name; $('joinBtn').disabled = false; };
                    }
                    box.appendChild(row);
                });
            }

            async function ensureConnected() {
                if (connected) return;
                connection.on("Welcome", id => { myId = id; });
                connection.on("RoomsSnapshot", list => { renderRoomsList(list || []); });
                connection.on("RoomBusy", roomName => { show('joinError'); });

                // Roster: (ids, leaderId)
                connection.on("Roster", (ids, leadId) => {
                    leaderId = leadId || null;
                    const prev = new Map(others);
                    others.clear();
                    const arr = Array.from(ids || []);
                    if (myId && !arr.includes(myId)) arr.push(myId);
                    for (const id of arr) {
                        if (id === myId) continue;
                        const old = prev.get(id);
                        others.set(id, old || { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0, hp: 100, dead: false });
                    }
                    roleHud(); renderLobby();
                });

                connection.on("PlayerJoined", id => {
                    if (id !== myId) others.set(id, { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0, hp: 100, dead: false });
                    renderLobby();
                });
                connection.on("PlayerLeft", id => { others.delete(id); names.delete(id); renderLobby(); });
                connection.on("NamesSnapshot", dict => { names.clear(); for (const k in dict) names.set(k, dict[k]); renderLobby(); });
                connection.on("PlayerNamed", (id, name) => { names.set(id, name); renderLobby(); });
                connection.on("GameState", state => { inGame = !!state; });

                connection.on("JoinAccepted", rn => {
                    room = rn;
                    connection.invoke("SetName", room, (State.myName || 'Spiller')).catch(() => { });
                    roleHud(); renderLobby(); hide('menu'); show('lobby');
                });

                connection.on("GameStarted", () => {
                    roleHud();
                    inGame = true; hide('lobby');
                    if (isHost && State.obstacles.length === 0) {
                        MapGen.makeOpenArena();
                        // Lad tick-loopet sende snapshot’et første gang efter spillet starter:
                        Game._sentObstacles = false;
                    }
                    // reset hp/alive
                    State.player.hp = 100; State.player.alive = true;
                    for (const [, o] of others) { o.hp = 100; o.dead = false; }
                    Game.startMatch('mp');
                });

                // GameEnded(finalScore)
                connection.on("GameEnded", (finalScore) => {
                    inGame = false;
                    Game.endToLobby();
                    $('lastScore').textContent = String(finalScore | 0);
                    show('lobby');
                });

                connection.on("State", (id, ps) => {
                    if (id === myId) return;
                    let o = others.get(id);
                    if (!o) { o = { x: ps.x, y: ps.y, tx: ps.x, ty: ps.y, aim: ps.aim || 0, weaponIndex: 0, hp: 100, dead: false }; others.set(id, o); }
                    o.tx = ps.x; o.ty = ps.y; o.aim = ps.aim || 0;
                });

                connection.on("WeaponChanged", (id, idx) => {
                    if (id === myId) return;
                    const o = others.get(id) || { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0, hp: 100, dead: false };
                    o.weaponIndex = idx | 0; others.set(id, o);
                });

                connection.on("Enemies", list => { if (!isHost) applyEnemies(list); });
                connection.on("Obstacles", list => { if (!isHost) applyObstacles(list); });
                connection.on("Pickups", list => { if (!isHost) applyPickups(list); });

                connection.on("GrantAmmo", (wpnIndex, amount) => {
                    const slot = (wpnIndex | 0) + 1;
                    State.ammo[slot] = (State.ammo[slot] || 0) + (amount | 0);
                    HUDupdate();
                });

                // HP ændringer broadcastet af host
                connection.on("HpChanged", (targetId, hp, alive) => {
                    if (targetId === myId) {
                        State.player.hp = Math.max(0, hp | 0);
                        State.player.alive = !!alive;

                        if (!State.player.alive) {
                            // stop input når man er død (man kan stadig se kampen)
                            Input.mouse.down = false;
                            State.player.vx = 0; State.player.vy = 0;
                        }
                    } else {
                        const o = others.get(targetId);
                        if (o) { o.hp = Math.max(0, hp | 0); o.dead = !alive; }
                    }
                    HUDupdate();
                    renderLobby();
                });

                connection.on("ShootRequest", (shooterId, payload) => {
                    if (!isHost) return;
                    if (ShotCache.has(payload.uid)) return;
                    ShotCache.add(payload.uid);
                    connection.invoke("ShootEvent", room, shooterId, payload).catch(() => { });
                    spawnShot(shooterId, payload, State.bullets);
                });

                connection.on("ShootEvent", (shooterId, payload) => {
                    if (ShotCache.has(payload.uid)) return;
                    ShotCache.add(payload.uid);
                    const target = isHost ? State.bullets : Remote.bullets;
                    spawnShot(shooterId, payload, target);
                });

                await connection.start();
                connected = true;
                const list = await connection.invoke("GetRooms");
                renderRoomsList(list || []);
            }

            async function connectAndJoin(r, playerName) {
                await ensureConnected();
                hide('joinError');
                State.myName = playerName;
                await connection.invoke("Join", r);
            }

            function setName(n) { if (!room) return; names.set(myId, n); connection.invoke("SetName", room, n).catch(() => { }); }
            function startGame() {
                if (!room) return;
                // Denne klient er host når den trykker på knappen
                isHost = true;
                leaderId = myId;            // <- vigtigt: gør også lederId lokalt til mig
                roleHud();                  // opdater hele HUD ift. rolle
                connection.invoke("StartGame", room).catch(() => { });
            }
            function endGame(finalScore) { if (!room) return; connection.invoke("EndGame", room, finalScore | 0).catch(() => { }); }

            async function leaveRoom() {
                if (!room) return;
                try { await connection.invoke("Leave", room); } catch { }
                room = null; leaderId = null; others.clear(); names.clear(); inGame = false; isHost = false;
                roleHud(); renderLobby();
            }

            function sendState() {
                if (!room) return;
                const p = State.player;
                connection.invoke("UpdateSelf", { Room: room, X: p.x, Y: p.y, VX: p.vx, VY: p.vy, Aim: State.aim || 0, ClientTs: performance.now() | 0 }).catch(() => { });
            }
            function sendEnemiesSnapshot(list) { if (isHost && room) connection.invoke("EnemiesSnapshot", room, list).catch(() => { }); }
            function sendObstaclesSnapshot(list) { if (isHost && room) connection.invoke("ObstaclesSnapshot", room, list).catch(() => { }); }
            function sendPickupsSnapshot(list) { if (isHost && room) connection.invoke("PickupsSnapshot", room, list).catch(() => { }); }
            function sendWeaponChanged(idx) { if (room) connection.invoke("WeaponChanged", room, idx | 0).catch(() => { }); }
            function sendShootRequest(payload) { if (room) connection.invoke("ShootRequest", room, payload).catch(() => { }); }
            function sendShootEvent(shooterId, payload) { if (room) connection.invoke("ShootEvent", room, shooterId, payload).catch(() => { }); }
            function grantAmmoTo(targetId, wpnIndex, amount) {
                if (!room) return;
                if (targetId === myId) {
                    const slot = (wpnIndex | 0) + 1;
                    State.ammo[slot] = (State.ammo[slot] || 0) + (amount | 0);
                    HUDupdate();
                } else {
                    connection.invoke("GrantAmmo", room, targetId, (wpnIndex | 0), (amount | 0)).catch(() => { });
                }
            }
            function hpChanged(targetId, hp, alive) {
                if (!room) return;
                connection.invoke("HpChanged", room, targetId, hp | 0, !!alive).catch(() => { });
            }

            function getOthers() { return others; }
            function getIsHost() {
                // Lokalt flag vinder: hvis jeg selv har markeret mig som host (klik på "Start spil"),
                // skal jeg simulere fjender, skade osv. Ellers falder vi tilbage til serverens leaderId.
                if (isHost) return true;
                return (!!leaderId && !!myId && leaderId === myId);
            }

            function getMyId() { return myId; }
            function getName(id) { return names.get(id) || ""; }
            function getRoom() { return room; }
            async function fetchRooms() { try { const list = await connection.invoke("GetRooms"); renderRoomsList(list || []); } catch (e) { } }

            return {
                ensureConnected, connectAndJoin, leaveRoom,
                setName, startGame, endGame,
                sendState, sendEnemiesSnapshot, sendObstaclesSnapshot, sendPickupsSnapshot,
                sendWeaponChanged, sendShootRequest, sendShootEvent, grantAmmoTo, hpChanged,
                getOthers, getIsHost, getMyId, getName, getRoom, fetchRooms
            };
        })();

        /* ------------ game state ------------ */
        const canvas = $('game'); const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        const Config = Object.freeze({
            bounds: { x: 60, y: 60, w: W - 120, h: H - 120 },
            friction: 0.86,
            dash: { cool: 900, speed: 7 },
            player: { speed: 0.5, size: 22, hp: 100 },
            spawn: { perWaveBase: 6, perWaveScale: 1.1, maxBatch: 22 },
            pickups: { max: 3, spawnMin: 20000, spawnMax: 30000 },
            fixedDt: 1000 / 60
        });

        const Weapons = [
            { key: '1', name: 'Pistol', dmg: 20, speed: 10, cd: 500, spread: 0.02, pellets: 1, pierce: 0, life: 900, ammoCost: 0, pickup: 0 },
            { key: '2', name: 'Shotgun', dmg: 14, speed: 9, cd: 600, spread: 0.18, pellets: 8, pierce: 0, life: 500, ammoCost: 1, pickup: 40 },
            { key: '3', name: 'Riffel', dmg: 22, speed: 14, cd: 90, spread: 0.01, pellets: 1, pierce: 0, life: 1100, ammoCost: 1, pickup: 120 }
        ];

        const Save = { get highScore() { return parseInt(localStorage.getItem('boxhead_highscore')) || 0; }, set highScore(v) { localStorage.setItem('boxhead_highscore', String(v | 0)); } };

        const hud = { weapon: $('weapon'), ammo: $('ammo'), score: $('score'), wave: $('wave'), hp: $('hp') };

        const MathX = { rand(a, b) { return Math.random() * (b - a) + a; }, clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }, norm(x, y) { const l = Math.hypot(x, y) || 1; return [x / l, y / l]; } };

        const Input = (() => {
            const keys = new Set(); const mouse = { x: W / 2, y: H / 2, down: false };
            window.addEventListener('keydown', e => {
                if (e.code === 'KeyP') { Game.paused = !Game.paused; return; }
                if (e.code === 'Space') { mouse.down = true; }
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') Systems.tryDash();
                keys.add(e.code); Systems.handleWeaponKeys(e.code);
            });
            window.addEventListener('keyup', e => { if (e.code === 'Space') mouse.down = false; keys.delete(e.code); });
            canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width / r.width); mouse.y = (e.clientY - r.top) * (canvas.height / r.height); });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            canvas.addEventListener('mouseup', () => mouse.down = false);
            return { keys, mouse };
        })();

        const State = (() => {
            const player = { x: W / 2, y: H / 2, vx: 0, vy: 0, size: Config.player.size, speed: Config.player.speed, hp: Config.player.hp, alive: true };
            const bullets = [], enemies = [], particles = [], obstacles = [], pickups = [];
            let weaponIndex = 0; const ammo = { 1: Infinity, 2: 0, 3: 0 };
            let score = 0, wave = 1, spawnTimer = 0, pickupTimer = 0, lastFire = -1e9;
            let highScore = Save.highScore; let myName = ''; let aim = 0;
            return { player, bullets, enemies, particles, obstacles, pickups, weaponIndex, ammo, score, wave, spawnTimer, pickupTimer, lastFire, highScore, myName, aim };
        })();

        const Remote = { bullets: [] };
        const ShotCache = new Set();

        /* ------------ MENU/Lobby UI ------------ */
        function toMenu() { show('menu'); hide('lobby'); $('roomInput').value = ''; $('joinBtn').disabled = true; }
        function toLobby() { hide('menu'); show('lobby'); }

        $('mpToggle').onclick = async () => { $('mpPanel').classList.toggle('hidden'); if (!$('mpPanel').classList.contains('hidden')) { await NET.ensureConnected(); } };
        $('roomInput').oninput = () => $('joinBtn').disabled = !$('roomInput').value.trim();
        $('restart').onclick = async () => {
            if (NET.getRoom()) { await NET.leaveRoom(); }
            Game.endToMenu();
        };

        $('spBtn').onclick = () => { const nm = $('nameInput').value.trim().slice(0, 20); State.myName = nm || 'Spiller'; hide('menu'); Game.startMatch('sp'); };
        $('joinBtn').onclick = async () => {
            hide('joinError');
            const nm = ($('nameInput').value || '').trim().slice(0, 20) || 'Spiller';
            const room = $('roomInput').value.trim().toLowerCase().replace(/[^a-z0-9\-_.]/g, '-').slice(0, 24);
            if (!room) return;
            await NET.connectAndJoin(room, nm);
        };
        $('refreshRooms').onclick = async () => { await NET.ensureConnected(); await NET.fetchRooms(); };
        $('startMatchBtn').onclick = () => { NET.startGame(); };
        $('lobbyBackBtn').onclick = async () => {
            if (NET.getRoom()) { await NET.leaveRoom(); } // hvis du stod i et rum
            toMenu();                                     // tilbage til SP/MP menuen
        };


        /* ------------ HUD ------------ */
        function HUDupdate() {
            const w = Weapons[State.weaponIndex];
            hud.weapon.textContent = w.name;
            const a = State.ammo[State.weaponIndex + 1];
            hud.ammo.textContent = (a === Infinity) ? '∞' : String(a | 0);
            hud.score.textContent = State.score;
            hud.wave.textContent = State.wave;
            hud.hp.textContent = Math.max(0, Math.ceil(State.player.hp));
        }

        /* ------------ Map & apply ------------ */
        const MapGen = {
            makeOpenArena() {
                State.obstacles.length = 0;
                const b = Config.bounds;
                const n = Math.floor(MathX.rand(10, 21));
                for (let i = 0; i < n; i++) {
                    const w = MathX.rand(60, 120), h = MathX.rand(60, 120);
                    const x = MathX.rand(b.x + 20, b.x + b.w - w - 20);
                    const y = MathX.rand(b.y + 20, b.y + b.h - h - 20);
                    const startSafe = { x: W / 2 - 200, y: H / 2 - 200, w: 400, h: 400 };
                    if (x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y) { i--; continue; }
                    State.obstacles.push({ x, y, w, h });
                }
            }
        };
        function applyEnemies(list) { State.enemies.length = 0; for (const e of list) State.enemies.push({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color, vx: 0, vy: 0 }); }
        function applyObstacles(list) { State.obstacles.length = 0; for (const o of list) State.obstacles.push({ x: o.x, y: o.y, w: o.w, h: o.h }); }
        function applyPickups(list) { State.pickups.length = 0; for (const p of list) State.pickups.push({ x: p.x, y: p.y, w: p.w, h: p.h, type: p.type }); }

        /* ------------ Particles ------------ */
        const Particles = {
            puff(x, y, n = 12, speed = 3, life = 500, color = 'rgba(255,255,255,1)') {
                for (let i = 0; i < n; i++) {
                    const a = MathX.rand(0, Math.PI * 2), v = MathX.rand(0.5, speed);
                    State.particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life, max: life, color, full: false });
                }
            },
            flash(color) { State.particles.push({ x: W / 2, y: H / 2, vx: 0, vy: 0, life: 160, max: 160, color, full: true }); },
            update(dt) {
                for (let i = State.particles.length - 1; i >= 0; i--) {
                    const p = State.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= dt;
                    if (p.life <= 0) State.particles.splice(i, 1);
                }
            },
            render(ctx) {
                for (const p of State.particles) {
                    if (p.full) {
                        const t = Math.max(0, p.life / p.max);
                        ctx.save(); ctx.globalAlpha = 0.25 * t; ctx.fillStyle = p.color; ctx.fillRect(0, 0, W, H); ctx.restore();
                    } else {
                        const t = Math.max(0, p.life / p.max);
                        ctx.save(); ctx.globalAlpha = t * t; ctx.fillStyle = p.color;
                        ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                    }
                }
            }
        };

        /* ------------ Systems ------------ */
        const Systems = {
            handleWeaponKeys(code) {
                const map = { Digit1: 0, Digit2: 1, Digit3: 2 };
                if (code in map) {
                    State.weaponIndex = map[code];
                    if (Game.mode === 'mp') NET.sendWeaponChanged(State.weaponIndex);
                    HUDupdate();
                }
            },
            tryDash() {
                const now = performance.now();
                if (!Systems._dashLast) Systems._dashLast = -9999;
                if (now - Systems._dashLast < Config.dash.cool) return;
                let dx = 0, dy = 0;
                const k = Input.keys;
                if (k.has('KeyW')) dy -= 1; if (k.has('KeyS')) dy += 1;
                if (k.has('KeyA')) dx -= 1; if (k.has('KeyD')) dx += 1;
                if (!dx && !dy) return;
                const [nx, ny] = MathX.norm(dx, dy);
                State.player.vx += nx * Config.dash.speed;
                State.player.vy += ny * Config.dash.speed;
                Particles.puff(State.player.x, State.player.y, 14, 4, 300, 'rgba(77,226,204,1)');
                Systems._dashLast = now;
            },
            shoot() {
                if (!State.player.alive) return; 
                const w = Weapons[State.weaponIndex];
                const now = performance.now();
                if (now - State.lastFire < w.cd) return;
                if (w.ammoCost > 0) {
                    const slot = State.weaponIndex + 1;
                    if (!State.ammo[slot] || State.ammo[slot] <= 0) { State.lastFire = now; return; }
                    State.ammo[slot] -= w.ammoCost;
                }
                State.lastFire = now;
                const uid = (Game.mode === 'mp' ? (NET.getMyId() || 'me') : 'sp') + ':' + (now | 0) + ':' + State.weaponIndex;
                const payload = { x: State.player.x, y: State.player.y, angle: State.aim, weaponIndex: State.weaponIndex, ts: now | 0, uid };
                if (Game.mode === 'mp') {
                    if (NET.getIsHost()) {
                        NET.sendShootEvent(NET.getMyId() || "", payload);
                        if (!ShotCache.has(uid)) { ShotCache.add(uid); spawnShot(NET.getMyId() || "", payload, State.bullets); }
                    } else {
                        NET.sendShootRequest(payload);
                    }
                } else {
                    spawnShot('sp', payload, Remote.bullets);
                }
                HUDupdate();
            },
            movePlayer(dt) {
                if (!State.player.alive) return;
                let ax = 0, ay = 0; const k = Input.keys;
                if (k.has('KeyW')) ay -= 1; if (k.has('KeyS')) ay += 1;
                if (k.has('KeyA')) ax -= 1; if (k.has('KeyD')) ax += 1;
                if (ax || ay) { const [nx, ny] = MathX.norm(ax, ay); State.player.vx += nx * State.player.speed; State.player.vy += ny * State.player.speed; }
                State.player.vx *= Config.friction; State.player.vy *= Config.friction;
                State.player.x += State.player.vx; State.player.y += State.player.vy;
                Systems.resolveAABB(State.player, State.player.size);
            },
            moveBullets(dt, list) {
                for (let i = list.length - 1; i >= 0; i--) {
                    const b = list[i];
                    b.x += b.vx; b.y += b.vy; b.life -= dt;
                    let hit = false;
                    for (const o of State.obstacles) {
                        if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) { hit = true; break; }
                    }
                    if (hit) { Particles.puff(b.x, b.y, 6, 1.1, 200, 'rgba(230,236,243,1)'); list.splice(i, 1); continue; }
                    if (b.x < -50 || b.y < -50 || b.x > W + 50 || b.y > H + 50 || b.life <= 0) list.splice(i, 1);
                }
            },
            cullRemoteBullets() {
                for (let i = Remote.bullets.length - 1; i >= 0; i--) {
                    const b = Remote.bullets[i];
                    for (const e of State.enemies) {
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) { Remote.bullets.splice(i, 1); break; }
                    }
                }
            },
            moveEnemies(dt) {
                const targets = [{ id: NET.getMyId() || 'me', x: State.player.x, y: State.player.y, self: true }];
                if (Game.mode === 'mp') for (const [id, o] of NET.getOthers()) targets.push({ id, x: o.tx ?? o.x, y: o.ty ?? o.y, self: false });

                for (const e of State.enemies) {
                    // find nærmeste LEVENDE spiller
                    let tx = null, ty = null, best = Infinity;
                    for (const t of targets) {
                        const alive = t.self ? State.player.alive : !(NET.getOthers().get(t.id)?.dead);
                        if (!alive) continue;
                        const d2 = (t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y);
                        if (d2 < best) { best = d2; tx = t.x; ty = t.y; }
                    }
                    if (tx !== null) {
                        const dx = tx - e.x, dy = ty - e.y, d = Math.hypot(dx, dy) + 1e-4;
                        const s = e.spd * (1 + Math.min(0.6, 30 / d));
                        e.vx = (dx / d) * s; e.vy = (dy / d) * s;
                        e.x += e.vx; e.y += e.vy;
                        Systems.resolveAABB(e, e.size);
                    }
                }
            },
            resolveAABB(ent, size) {
                const b = Config.bounds;
                ent.x = MathX.clamp(ent.x, b.x + size / 2, b.x + b.w - size / 2);
                ent.y = MathX.clamp(ent.y, b.y + size / 2, b.y + b.h - size / 2);
                for (const o of State.obstacles) {
                    const ex = ent.x - size / 2, ey = ent.y - size / 2, ew = size, eh = size;
                    if (ex < o.x + o.w && ex + ew > o.x && ey < o.y + o.h && ey + eh > o.y) {
                        const dx1 = (o.x + o.w) - ex, dx2 = (ex + ew) - o.x, dy1 = (o.y + o.h) - ey, dy2 = (ey + eh) - o.y;
                        const m = Math.min(dx1, dx2, dy1, dy2);
                        if (m === dx1) ent.x = o.x + o.w + size / 2;
                        else if (m === dx2) ent.x = o.x - size / 2;
                        else if (m === dy1) ent.y = o.y + o.h + size / 2;
                        else ent.y = o.y - size / 2;
                    }
                }
            },

            // Host-only: beregn skade på ALLE spillere & afgør game over
            damageAllPlayers(dt) {
                if (!(Game.mode === 'mp' && NET.getIsHost())) return;

                const candidates = [];
                // host selv
                candidates.push({
                    id: NET.getMyId() || 'me',
                    x: State.player.x, y: State.player.y,
                    hp: State.player.hp, alive: State.player.alive, self: true
                });
                // alle andre
                for (const [id, o] of NET.getOthers()) {
                    candidates.push({
                        id,
                        x: (o.tx ?? o.x), y: (o.ty ?? o.y),
                        hp: (o.hp ?? 100),
                        alive: !o.dead,
                        self: false
                    });
                }

                const dmgPerSec = 10;

                // kontakt-skade
                for (const e of State.enemies) {
                    for (const c of candidates) {
                        if (!c.alive) continue;
                        if (Math.hypot(c.x - e.x, c.y - e.y) < e.size + State.player.size - 6) {
                            c.hp -= dmgPerSec * dt / 1000;

                            if (c.hp <= 0 && c.alive) {
                                c.hp = 0; c.alive = false;
                                NET.hpChanged(c.id, 0, false);      // broadcast død
                            } else {
                                NET.hpChanged(c.id, Math.ceil(Math.max(0, c.hp)), c.alive);
                            }
                        }
                    }
                }

                // opdatér hosts lokale spejl og check om nogen lever
                let anyAlive = false;
                for (const c of candidates) {
                    if (c.self) {
                        State.player.hp = c.hp; State.player.alive = c.alive;
                    } else {
                        const o = NET.getOthers().get(c.id);
                        if (o) { o.hp = c.hp; o.dead = !c.alive; }
                    }
                    anyAlive = anyAlive || c.alive;
                }

                // 🔧 NYT: Sørg for at HUD'en (HP i topbaren) og lobby-listen opdateres på hosten
                HUDupdate();
                renderLobby();

                if (!anyAlive) {
                    // først når ALLE er døde, stopper kampen
                    NET.endGame(State.score | 0);
                }
            },

            bulletsVsEnemies(list) {
                for (let i = State.enemies.length - 1; i >= 0; i--) {
                    const e = State.enemies[i];
                    for (let j = list.length - 1; j >= 0; j--) {
                        const b = list[j];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                            e.hp -= (b.damage || 20);
                            if (e.hp <= 0) {
                                Particles.puff(e.x, e.y, 18, 2.4, 500, 'rgba(255,107,107,1)');
                                State.enemies.splice(i, 1);
                                State.score += 10;
                            }
                            if (b.pierce && b.pierce > 0) {
                                b.pierce--; Particles.puff(e.x, e.y, 8, 2.0, 400, 'rgba(255,80,80,1)');
                            } else {
                                list.splice(j, 1); Particles.puff(e.x, e.y, 8, 2.0, 400, 'rgba(255,80,80,1)');
                            }
                            break;
                        }
                    }
                }
            },
            spawnPickup() {
                const options = [2, 3, 3];
                const type = options[Math.floor(Math.random() * options.length)];
                const b = Config.bounds; const w = 28, h = 28;
                for (let tries = 0; tries < 50; tries++) {
                    const x = MathX.rand(b.x + 20, b.x + b.w - w - 20), y = MathX.rand(b.y + 20, b.y + b.h - h - 20);
                    const startSafe = { x: W / 2 - 160, y: H / 2 - 160, w: 320, h: 320 };
                    let bad = x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y;
                    for (const o of State.obstacles) {
                        if (x < o.x + o.w && x + w > o.x && y < o.y + o.h && y + h > o.y) { bad = true; break; }
                    }
                    if (!bad) { State.pickups.push({ x, y, w, h, type }); break; }
                }
            },
            tryPickup() {
                // I MP er det KUN host der bestemmer picks og uddeler ammo
                if (Game.mode === 'mp' && !NET.getIsHost()) return;

                function give(toId, type) {
                    const w = Weapons[type - 1];
                    NET.grantAmmoTo(toId, (type - 1), w.pickup | 0);
                }

                const candidates = [{ id: NET.getMyId() || 'sp', x: State.player.x, y: State.player.y }];
                if (Game.mode === 'mp' && NET.getIsHost()) {
                    for (const [id, o] of NET.getOthers()) candidates.push({ id, x: o.tx ?? o.x, y: o.ty ?? o.y });
                }

                for (let i = State.pickups.length - 1; i >= 0; i--) {
                    const p = State.pickups[i];
                    let pickedBy = null;
                    for (const c of candidates) {
                        if (c.x > p.x && c.x < p.x + p.w && c.y > p.y && c.y < p.y + p.h) { pickedBy = c; break; }
                    }
                    if (pickedBy) {
                        give(pickedBy.id, p.type);
                        State.pickups.splice(i, 1);
                        if (Game.mode === 'mp' && NET.getIsHost()) {
                            NET.sendPickupsSnapshot(State.pickups.map(pp => ({ x: pp.x, y: pp.y, w: pp.w, h: pp.h, type: pp.type })));
                        }
                    }
                }
                HUDupdate();
            },
            spawnEnemy() {
                const edge = Math.floor(MathX.rand(0, 4)); let x, y;
                if (edge === 0) { x = MathX.rand(0, W); y = -20; }
                if (edge === 1) { x = W + 20; y = MathX.rand(0, H); }
                if (edge === 2) { x = MathX.rand(0, W); y = H + 20; }
                if (edge === 3) { x = -20; y = MathX.rand(0, H); }
                const r = Math.random();
                let type, size, hp, spd, color;
                if (r < 0.75) { type = 'normal'; size = MathX.rand(16, 24); hp = 10 + State.wave * 2 + MathX.rand(-2, 2); spd = 0.55 + Math.min(1.2, State.wave * 0.05) + MathX.rand(-0.08, 0.08); color = '#ff6b6b'; }
                else { type = 'big'; size = MathX.rand(36, 44); hp = 150 + State.wave * 6 + MathX.rand(-4, 4); spd = 0.35 + Math.min(0.7, State.wave * 0.03) + MathX.rand(-0.05, 0.05); color = '#ff9f43'; }
                State.enemies.push({ x, y, vx: 0, vy: 0, size, hp, spd, type, color });
            },
            nextWave() {
                State.wave++;
                for (let i = 0; i < Math.min(Config.spawn.perWaveBase + State.wave * Config.spawn.perWaveScale, Config.spawn.maxBatch); i++) Systems.spawnEnemy();
                State.player.hp = MathX.clamp(State.player.hp + 12, 0, 100);
                Particles.flash('#4de2cc');
            }
        };

        function spawnShot(shooterId, payload, list) {
            const w = Weapons[payload.weaponIndex];
            const base = payload.angle;
            for (let i = 0; i < w.pellets; i++) {
                const ang = base + w.spread * detSym(shooterId, payload.uid, i);
                const vx = Math.cos(ang) * w.speed, vy = Math.sin(ang) * w.speed;
                list.push({ x: payload.x + Math.cos(base) * (State.player.size + 8), y: payload.y + Math.sin(base) * (State.player.size + 8), vx, vy, life: w.life, damage: w.dmg, pierce: w.pierce });
            }
            Particles.puff(payload.x + Math.cos(base) * 14, payload.y + Math.sin(base) * 14, 6 + w.pellets, 1.2, 160, 'rgba(255,255,255,1)');
        }

        /* ------------ render ------------ */
        const Render = {
            drawGun(kind) {
                ctx.save();
                const baseX = 12, baseY = -3;
                if (kind === 0) { // pistol
                    ctx.fillStyle = '#d9dde6'; ctx.fillRect(baseX, baseY + 1, 16, 4);
                } else if (kind === 1) { // shotgun
                    ctx.fillStyle = '#b25d3b'; ctx.fillRect(baseX - 2, baseY - 1, 28, 6);
                    ctx.fillStyle = '#2d2f3a'; ctx.fillRect(baseX + 8, baseY - 2, 22, 3);
                } else { // rifle
                    ctx.fillStyle = '#a1b0ff'; ctx.fillRect(baseX, baseY, 34, 3);
                    ctx.fillRect(baseX + 6, baseY + 3, 10, 2);
                }
                ctx.restore();
            },
            draw() {
                ctx.clearRect(0, 0, W, H);
                const b = Config.bounds;

                // bg + grid
                ctx.save();
                ctx.fillStyle = '#0a0e1b'; ctx.fillRect(0, 0, W, H);
                ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = 2; ctx.strokeRect(b.x - 10, b.y - 10, b.w + 20, b.h + 20);
                ctx.globalAlpha = .06;
                for (let x = b.x; x < b.x + b.w; x += 40) { ctx.beginPath(); ctx.moveTo(x, b.y); ctx.lineTo(x, b.y + b.h); ctx.stroke(); }
                for (let y = b.y; y < b.y + b.h; y += 40) { ctx.beginPath(); ctx.moveTo(b.x, y); ctx.lineTo(b.x + b.w, y); ctx.stroke(); }
                ctx.globalAlpha = 1; ctx.restore();

                // crates
                ctx.save(); for (const o of State.obstacles) { ctx.fillStyle = '#1e243f'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.strokeRect(o.x + .5, o.y + .5, o.w - 1, o.h - 1); } ctx.restore();

                // pickups
                ctx.save();
                for (const p of State.pickups) {
                    let col = '#ffb84d'; if (p.type === 3) col = '#4da6ff';
                    ctx.fillStyle = col; ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.strokeRect(p.x + .5, p.y + .5, p.w - 1, p.h - 1);
                }
                ctx.restore();

                // particles
                Particles.render(ctx);

                // players (skip døde)
                function drawPlayer(x, y, aim, isSelf, name, weaponIndex, alive) {
                    if (!alive) return;
                    const s = 22, head = 12;
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(aim || 0);

                    // body
                    ctx.fillStyle = isSelf ? '#1b2a57' : '#2a335f';
                    ctx.fillRect(-s / 2, -s / 2, s, s);

                    // weapon
                    Render.drawGun(weaponIndex | 0);

                    // head
                    ctx.fillStyle = isSelf ? '#4de2cc' : '#9aa7ff';
                    ctx.fillRect(s / 2 - 2, -head / 2, head, head);

                    ctx.restore();

                    // nameplate
                    if (name) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(0,0,0,.45)';
                        ctx.fillRect(x - 60, y - 38, 120, 22);
                        ctx.fillStyle = '#e7ecf3';
                        ctx.font = '700 14px system-ui,sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(name, x, y - 22);
                        ctx.restore();
                    }
                }

                drawPlayer(State.player.x, State.player.y, State.aim, true, State.myName, State.weaponIndex, State.player.alive);
                if (Game.mode === 'mp') {
                    for (const [id, o] of NET.getOthers()) {
                        drawPlayer(o.x, o.y, o.aim || 0, false, NET.getName(id), o.weaponIndex || 0, !o.dead);
                    }
                }

                // enemies
                for (const e of State.enemies) {
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.fillStyle = e.color || '#ff6b6b';
                    ctx.fillRect(-e.size / 2, -e.size / 2, e.size, e.size);
                    ctx.fillStyle = '#10131f';
                    ctx.fillRect(-4, -4, 3, 3); ctx.fillRect(1, -4, 3, 3);
                    ctx.restore();
                }

                // bullets
                ctx.save(); ctx.fillStyle = '#e7ecf3';
                const bl = (Game.mode === 'mp' ? (NET.getIsHost() ? State.bullets : Remote.bullets) : Remote.bullets);
                for (const b of bl) ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
                ctx.restore();
            }
        };

        /* ------------ game ------------ */
        const Game = {
            mode: 'sp', running: false, paused: false, _loop: 0, _sentObstacles: false,

            startMatch(mode) {
                this.mode = mode; this.running = true; this.paused = false;
                State.enemies.length = 0; State.bullets.length = 0; Remote.bullets.length = 0;
                State.particles.length = 0; State.pickups.length = 0;
                State.player.x = W / 2; State.player.y = H / 2; State.player.vx = 0; State.player.vy = 0;
                State.player.hp = Config.player.hp; State.player.alive = true;
                State.weaponIndex = 0; State.ammo[2] = 0; State.ammo[3] = 0;
                State.score = 0; State.wave = 1; State.spawnTimer = 0; State.pickupTimer = 0; State.lastFire = -1e9;

                if (mode === 'sp') { MapGen.makeOpenArena(); }

                this._sentObstacles = false;

                let last = performance.now(), acc = 0, dt = Config.fixedDt;
                const loop = (ts) => {
                    if (!this.running) return;
                    const frame = ts - last; last = ts;
                    if (!this.paused) {
                        acc = Math.min(acc + frame, 250);
                        while (acc >= dt) { this.update(dt); acc -= dt; }
                        Render.draw(); HUDupdate();
                    }
                    this._loop = requestAnimationFrame(loop);
                };
                cancelAnimationFrame(this._loop);
                this._loop = requestAnimationFrame(loop);

                if (mode === 'mp') {
                    const tick = () => {
                        if (!this.running) return;
                        if (NET.getIsHost()) {
                            const es = State.enemies.map(e => ({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color }));
                            NET.sendEnemiesSnapshot(es);

                            if (!this._sentObstacles && State.obstacles.length > 0) {
                                NET.sendObstaclesSnapshot(State.obstacles.map(o => ({ x: o.x, y: o.y, w: o.w, h: o.h })));
                                this._sentObstacles = true;
                            }

                            // pickups snapshot diff
                            const now = performance.now() | 0;
                            if (!tick._lastPickupsSent || now - tick._lastPickupsSent > 200) {
                                const ps = State.pickups.map(p => ({ x: p.x, y: p.y, w: p.w, h: p.h, type: p.type }));
                                const str = JSON.stringify(ps);
                                if (str !== tick._lastPickupsStr) {
                                    NET.sendPickupsSnapshot(ps);
                                    tick._lastPickupsStr = str;
                                }
                                tick._lastPickupsSent = now;
                            }
                        }
                        setTimeout(tick, 50);
                    };
                    tick._lastPickupsSent = 0; tick._lastPickupsStr = "";
                    tick();
                }
            },

            update(dt) {
                const dx = Input.mouse.x - State.player.x, dy = Input.mouse.y - State.player.y;
                State.aim = Math.atan2(dy, dx);
                if (Input.mouse.down) Systems.shoot();
                Systems.movePlayer(dt);

                if (this.mode === 'mp') {
                    if (NET.getIsHost()) {
                        Systems.moveEnemies(dt);
                        // VIGTIGT: host skader alle spillere og afgør game over
                        Systems.damageAllPlayers(dt);
                        Systems.bulletsVsEnemies(State.bullets);
                        Systems.moveBullets(dt, State.bullets);

                        State.spawnTimer -= dt; State.pickupTimer -= dt;
                        if (State.spawnTimer <= 0) {
                            const perSec = Math.min(0.5 + State.wave * 0.18, 2.0);
                            State.spawnTimer = 1000 / perSec; Systems.spawnEnemy();
                        }
                        if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) {
                            State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax);
                            Systems.spawnPickup();
                        }
                        if (State.score > State.wave * 150) Systems.nextWave();
                    } else {
                        Systems.moveBullets(dt, Remote.bullets);
                        Systems.cullRemoteBullets();
                    }

                    NET.sendState();
                    for (const [, o] of NET.getOthers()) {
                        const s = 0.18; o.x += (o.tx - o.x) * s; o.y += (o.ty - o.y) * s;
                    }
                } else {
                    // Singleplayer
                    Systems.moveEnemies(dt);
                    // lokal touch-dmg på spilleren
                    for (const e of State.enemies) {
                        if (Math.hypot(State.player.x - e.x, State.player.y - e.y) < e.size + State.player.size - 6) {
                            State.player.hp -= 10 * dt / 1000;
                            if (State.player.hp <= 0) { this.onLocalDeath(); break; }
                        }
                    }
                    Systems.bulletsVsEnemies(Remote.bullets);
                    Systems.moveBullets(dt, Remote.bullets);

                    State.spawnTimer -= dt; State.pickupTimer -= dt;
                    if (State.spawnTimer <= 0) {
                        const perSec = Math.min(0.5 + State.wave * 0.18, 2.0);
                        State.spawnTimer = 1000 / perSec; Systems.spawnEnemy();
                    }
                    if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) {
                        State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax);
                        Systems.spawnPickup();
                    }
                    if (State.score > State.wave * 150) Systems.nextWave();
                }

                Particles.update(dt);
                Systems.tryPickup();
            },

            onLocalDeath() {
                // I MP styres dødsfald af host via HpChanged (ingen lokal afslutning her)
                if (this.mode === 'sp') {
                    State.player.alive = false;
                    this.endSingleplayerToLobbyWithScore();
                }
            },

            endToLobby() { this.running = false; this.paused = false; show('lobby'); },
            endToMenu() {
                this.running = false;
                this.paused = false;
                // "Til menu"-knappen skal ALTID sende tilbage til hovedmenuen
                toMenu();
            },

            endSingleplayerToLobbyWithScore() {
                this.running = false;
                this.paused = false;
                $('lastScore').textContent = String(State.score | 0);
                show('lobby');
            }
        };

        // initial: vis menu og forbered net til room-liste
        toMenu();
        NET.ensureConnected();
    </script>
</body>
</html>
