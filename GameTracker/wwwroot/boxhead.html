<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Box Head – Mini Shooter (Low‑bandwidth multiplayer)</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #161a2e;
            --ink: #e7ecf3;
            --accent: #4de2cc;
        }

        html, body {
            margin: 0;
            height: 100%;
            background: radial-gradient(1200px 800px at 30% 20%, #1a1e36, var(--bg));
            color: var(--ink);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            background: color-mix(in oklab, var(--panel) 90%, black);
            padding: 10px 14px;
            border-radius: 14px;
            z-index: 20;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06)
        }

        .pill {
            background: #0f1430;
            padding: 6px 10px;
            border-radius: 999px;
            opacity: .9
        }

        .btn {
            cursor: pointer;
            padding: 8px 14px;
            border-radius: 12px;
            background: var(--accent);
            color: #012321;
            font-weight: 700;
            border: none
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: #0b0e1a;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.04)
        }

        .overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5,8,20,.55);
            backdrop-filter: saturate(120%) blur(4px);
            z-index: 30
        }

        .card {
            width: min(820px,calc(100% - 24px));
            background: var(--panel);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,.5)
        }

        .row {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            align-items: center
        }

        .kbd {
            font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
            background: #0b1026;
            padding: 2px 6px;
            border-radius: 6px
        }

        .host-pill {
            outline: 2px solid var(--accent);
        }

        .nameform {
            display: flex;
            gap: 10px;
            margin-top: 14px;
        }

            .nameform input {
                flex: 1;
                padding: 10px 12px;
                border-radius: 10px;
                border: 1px solid rgba(255,255,255,.08);
                background: #0b1026;
                color: var(--ink);
            }

            .nameform button {
                padding: 10px 14px;
                border-radius: 10px;
                background: var(--accent);
                color: #012321;
                font-weight: 800;
                border: none;
            }

        .namehint {
            font-size: .9rem;
            opacity: .8;
            margin-top: 6px
        }

        .name {
            font: 700 14px/1 system-ui, sans-serif;
            text-align: center;
            transform: translate(-50%, -10px);
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="hud">
        <span class="pill">Våben: <b id="weapon">Pistol</b></span>
        <span class="pill">Ammo: <b id="ammo">∞</b></span>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Wave: <b id="wave">1</b></span>
        <span class="pill">HP: <b id="hp">100</b></span>
        <span class="pill" id="netrole">Net: <b id="role">—</b></span>
        <button id="restart" class="btn">Genstart</button>
    </div>

    <canvas id="game" width="1600" height="900"></canvas>

    <!-- Startmenu med navn -->
    <div class="overlay" id="startOverlay">
        <div class="card">
            <h2 style="margin:0 0 8px">Skriv dit navn for at starte</h2>
            <p class="namehint">Navnet vises over din karakter og deles med andre spillere i rummet.</p>
            <div class="nameform">
                <input id="playerName" type="text" maxlength="20" placeholder="Fx: Hedef" />
                <button id="startBtn" disabled>Start spil</button>
            </div>
            <div style="margin-top:12px">
                <div>Bevægelse: <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span> • Dash: <span class="kbd">Shift</span></div>
                <div>Sigte: mus • Skyd: venstre klik / <span class="kbd">Mellemrum</span> • Pause: <span class="kbd">P</span></div>
                <div>Våben: <span class="kbd">1</span> Pistol (∞), <span class="kbd">2</span> Shotgun, <span class="kbd">3</span> Riffel</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>

    <script>
        'use strict';

        /* ===================== Deterministisk RNG (til skud) ===================== */
        function hash32(str) { let h = 2166136261 >>> 0; for (let i = 0; i < str.length; i++) { h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); } return h >>> 0; }
        function xorshift32(seed) { let x = seed >>> 0; return function () { x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return (x >>> 0) / 4294967296; }; }
        function detRandSym(shooterId, uid, i) { const seed = (hash32(shooterId) ^ hash32(uid) ^ (i * 0x9E3779B9)) >>> 0; const rnd = xorshift32(seed)(); return rnd * 2 - 1; }

        /* ===================== NET ===================== */
        const NET = (() => {
            const HUB_URL = "https://www.hedef.dk/gamehub";
            const connection = new signalR.HubConnectionBuilder()
                .withUrl(HUB_URL, { withCredentials: false })
                .withAutomaticReconnect([0, 1000, 3000, 5000])
                .build();

            let myId = null;
            const others = new Map();      // id -> {x,y,tx,ty,aim,weaponIndex}
            const names = new Map();      // id -> name
            let isHost = false;

            async function start() {
                connection.on("Welcome", id => { myId = id; });

                connection.on("Roster", ids => decideHost(ids));
                connection.on("PlayerJoined", id => { });
                connection.on("PlayerLeft", id => { others.delete(id); names.delete(id); });

                connection.on("PlayerNamed", (id, name) => { names.set(id, name); });

                connection.on("State", (id, ps) => {
                    if (id === myId) return;
                    let o = others.get(id);
                    if (!o) { o = { x: ps.x, y: ps.y, tx: ps.x, ty: ps.y, aim: ps.aim || 0, weaponIndex: 0 }; others.set(id, o); }
                    o.tx = ps.x; o.ty = ps.y; o.aim = ps.aim || 0;
                });

                connection.on("WeaponChanged", (id, idx) => {
                    if (id === myId) return;
                    let o = others.get(id) || { x: 0, y: 0, tx: 0, ty: 0, aim: 0, weaponIndex: 0 };
                    o.weaponIndex = idx | 0; others.set(id, o);
                });

                connection.on("Enemies", list => { if (!isHost) applyEnemies(list); });
                connection.on("Obstacles", list => { if (!isHost) applyObstacles(list); });

                // Low‑bandwidth shooting:
                connection.on("ShootRequest", (shooterId, payload) => {
                    if (!isHost) return;
                    if (ShotCache.has(payload.uid)) return;
                    ShotCache.add(payload.uid);
                    // Host: broadcast ét ShootEvent til alle
                    connection.invoke("ShootEvent", "default", shooterId, payload).catch(() => { });
                    // Host spawner samtidig bullets lokalt (autoritativ)
                    spawnShotFromEvent(shooterId, payload, State.bullets);
                });

                connection.on("ShootEvent", (shooterId, payload) => {
                    if (ShotCache.has(payload.uid)) return;
                    ShotCache.add(payload.uid);
                    // Alle spawner samme bullets lokalt (clients i Remote, host i State)
                    const target = isHost ? State.bullets : Remote.bullets;
                    spawnShotFromEvent(shooterId, payload, target);
                });

                await connection.start();
                await connection.invoke("Join", "default");
                updateRoleHud();
            }

            function decideHost(ids) {
                const all = Array.from(ids || []);
                if (!all.includes(myId)) all.push(myId);
                all.sort();
                const newIsHost = (all[0] === myId);
                const changed = (newIsHost !== isHost);
                isHost = newIsHost;
                updateRoleHud();
                if (changed && isHost) {
                    // når man bliver host, udsend banen igen
                    sendObstaclesSnapshot(State.obstacles.map(o => ({ x: o.x, y: o.y, w: o.w, h: o.h })));
                }
            }

            function updateRoleHud() {
                const roleEl = document.getElementById('role');
                const roleWrap = document.getElementById('netrole');
                if (roleEl) roleEl.textContent = isHost ? 'Host' : 'Client';
                if (roleWrap) roleWrap.classList.toggle('host-pill', isHost);
            }

            function setName(name) {
                connection.invoke("SetName", "default", name).catch(() => { });
                names.set(myId, name);
            }

            function sendState() {
                if (connection.state !== signalR.HubConnectionState.Connected) return;
                const p = State.player;
                connection.invoke("UpdateSelf", {
                    Room: "default",
                    X: p.x, Y: p.y, VX: p.vx, VY: p.vy,
                    Aim: State.aim || 0,
                    ClientTs: performance.now() | 0
                }).catch(() => { });
            }

            function sendEnemiesSnapshot(list) {
                if (!isHost || connection.state !== signalR.HubConnectionState.Connected) return;
                connection.invoke("EnemiesSnapshot", "default", list).catch(() => { });
            }

            function sendObstaclesSnapshot(list) {
                if (!isHost || connection.state !== signalR.HubConnectionState.Connected) return;
                connection.invoke("ObstaclesSnapshot", "default", list).catch(() => { });
            }

            function sendWeaponChanged(idx) {
                connection.invoke("WeaponChanged", "default", idx | 0).catch(() => { });
            }

            function sendShootRequest(payload) {
                connection.invoke("ShootRequest", "default", payload).catch(() => { });
            }

            function sendShootEvent(shooterId, payload) {
                // bruges når den skydende er host – broadcast direkte
                connection.invoke("ShootEvent", "default", shooterId, payload).catch(() => { });
            }

            function getOthers() { return others; }
            function getIsHost() { return isHost; }
            function getMyId() { return myId; }
            function getName(id) { return names.get(id) || ""; }

            return { start, setName, sendState, sendEnemiesSnapshot, sendObstaclesSnapshot, sendWeaponChanged, sendShootRequest, sendShootEvent, getOthers, getIsHost, getMyId, getName };
        })();

        /* ===================== DOM/STATE ===================== */
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        const nameInput = document.getElementById('playerName');
        const startBtn = document.getElementById('startBtn');

        const hud = {
            weapon: document.getElementById('weapon'),
            ammo: document.getElementById('ammo'),
            score: document.getElementById('score'),
            wave: document.getElementById('wave'),
            hp: document.getElementById('hp'),
            startOverlay: document.getElementById('startOverlay'),
            restartBtn: document.getElementById('restart'),
        };

        const Config = Object.freeze({
            bounds: { x: 60, y: 60, w: W - 120, h: H - 120 },
            friction: 0.86,
            dash: { cool: 900, speed: 7 },
            player: { speed: 0.5, size: 22, hp: 100 },
            spawn: { perWaveBase: 6, perWaveScale: 1.1, maxBatch: 22 },
            pickups: { max: 3, spawnMin: 20000, spawnMax: 30000 },
            fixedDt: 1000 / 60
        });

        const Weapons = [
            { key: '1', name: 'Pistol', dmg: 20, speed: 10, cd: 500, spread: 0.02, pellets: 1, pierce: 0, life: 900, ammoCost: 0, pickup: 0 },
            { key: '2', name: 'Shotgun', dmg: 14, speed: 9, cd: 600, spread: 0.18, pellets: 8, pierce: 0, life: 500, ammoCost: 1, pickup: 40 },
            { key: '3', name: 'Riffel', dmg: 22, speed: 14, cd: 90, spread: 0.01, pellets: 1, pierce: 0, life: 1100, ammoCost: 1, pickup: 120 }
        ];

        const Save = {
            get highScore() { return parseInt(localStorage.getItem('boxhead_highscore')) || 0; },
            set highScore(v) { localStorage.setItem('boxhead_highscore', String(v | 0)); }
        };

        const MathX = {
            rand(a, b) { return Math.random() * (b - a) + a; },
            clamp(v, a, b) { return Math.max(a, Math.min(b, v)); },
            norm(x, y) { const l = Math.hypot(x, y) || 1; return [x / l, y / l]; }
        };

        const Input = (() => {
            const keys = new Set();
            const mouse = { x: W / 2, y: H / 2, down: false };
            window.addEventListener('keydown', e => {
                if (e.code === 'KeyP') { Game.paused = !Game.paused; return; }
                if (e.code === 'Space') { mouse.down = true; }
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') Systems.tryDash();
                keys.add(e.code); Systems.handleWeaponKeys(e.code);
            });
            window.addEventListener('keyup', e => { if (e.code === 'Space') mouse.down = false; keys.delete(e.code); });
            canvas.addEventListener('mousemove', e => {
                const r = canvas.getBoundingClientRect();
                mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
                mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
            });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            canvas.addEventListener('mouseup', () => mouse.down = false);
            return { keys, mouse };
        })();

        const State = (() => {
            const player = { x: W / 2, y: H / 2, vx: 0, vy: 0, size: Config.player.size, speed: Config.player.speed, hp: Config.player.hp, alive: true };
            const bullets = [];     // host: autoritative
            const enemies = [];
            const particles = [];
            const obstacles = [];
            const pickups = [];
            let weaponIndex = 0;
            const ammo = { 1: Infinity, 2: 0, 3: 0 };
            let score = 0, wave = 1, spawnTimer = 0, pickupTimer = 0, lastFire = -1e9;
            let highScore = Save.highScore;
            let myName = "";  // eget navn
            let aim = 0;      // egen sigtevinkel
            return { player, bullets, enemies, particles, obstacles, pickups, weaponIndex, ammo, score, wave, spawnTimer, pickupTimer, lastFire, highScore, myName, aim };
        })();

        const Remote = { bullets: [] };
        const ShotCache = new Set();

        /* ===================== HUD ===================== */
        const HUD = {
            update() {
                const w = Weapons[State.weaponIndex];
                hud.weapon.textContent = w.name;
                const a = State.ammo[State.weaponIndex + 1];
                hud.ammo.textContent = (a === Infinity) ? '∞' : String(a | 0);
                hud.score.textContent = State.score;
                hud.wave.textContent = State.wave;
                hud.hp.textContent = Math.max(0, Math.ceil(State.player.hp));
            },
            showOverlay() { if (hud.startOverlay) hud.startOverlay.style.display = 'grid'; },
            hideOverlay() { if (hud.startOverlay) hud.startOverlay.style.display = 'none'; },
        };

        /* ===================== Map & snapshots ===================== */
        const MapGen = {
            makeOpenArena() {
                State.obstacles.length = 0;
                const b = Config.bounds; const n = Math.floor(MathX.rand(10, 21));
                for (let i = 0; i < n; i++) {
                    const w = MathX.rand(60, 120), h = MathX.rand(60, 120);
                    const x = MathX.rand(b.x + 20, b.x + b.w - w - 20);
                    const y = MathX.rand(b.y + 20, b.y + b.h - h - 20);
                    const startSafe = { x: W / 2 - 200, y: H / 2 - 200, w: 400, h: 400 };
                    if (x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y) { i--; continue; }
                    State.obstacles.push({ x, y, w, h });
                }
            }
        };

        function applyEnemies(list) { State.enemies.length = 0; for (const e of list) State.enemies.push({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color, vx: 0, vy: 0 }); }
        function applyObstacles(list) { State.obstacles.length = 0; for (const o of list) State.obstacles.push({ x: o.x, y: o.y, w: o.w, h: o.h }); }

        /* ===================== Systems ===================== */
        const Systems = {
            handleWeaponKeys(code) {
                const map = { Digit1: 0, Digit2: 1, Digit3: 2 };
                if (code in map) { State.weaponIndex = map[code]; NET.sendWeaponChanged(State.weaponIndex); HUD.update(); }
            },
            tryDash() {
                const now = performance.now(); if (!Systems._dashLast) Systems._dashLast = -9999;
                if (now - Systems._dashLast < Config.dash.cool) return;
                let dx = 0, dy = 0; const k = Input.keys;
                if (k.has('KeyW')) dy -= 1; if (k.has('KeyS')) dy += 1; if (k.has('KeyA')) dx -= 1; if (k.has('KeyD')) dx += 1;
                if (!dx && !dy) return; const [nx, ny] = MathX.norm(dx, dy);
                State.player.vx += nx * Config.dash.speed; State.player.vy += ny * Config.dash.speed;
                Systems.puff(State.player.x, State.player.y, 14, 4, 300, 'rgba(77,226,204,.75)');
                Systems._dashLast = now;
            },
            shoot() {
                const w = Weapons[State.weaponIndex];
                const now = performance.now(); if (now - State.lastFire < w.cd) return;

                if (w.ammoCost > 0) {
                    const slot = State.weaponIndex + 1;
                    if (!State.ammo[slot] || State.ammo[slot] <= 0) { State.lastFire = now; return; }
                    State.ammo[slot] -= w.ammoCost;
                }
                State.lastFire = now;

                const uid = (NET.getMyId() || "me") + ":" + (now | 0) + ":" + State.weaponIndex;
                const payload = { x: State.player.x, y: State.player.y, angle: State.aim, weaponIndex: State.weaponIndex, ts: now | 0, uid };

                if (NET.getIsHost()) {
                    // Host: broadcast direkte + spawn lokalt autoritativt
                    NET.sendShootEvent(NET.getMyId() || "", payload);
                    // Host spawner også i State.bullets med samme event (via ShootEvent handler),
                    // men for at undgå evt. visual lag kan vi også spawne nu (dublettes undgås via ShotCache)
                    if (!ShotCache.has(uid)) { ShotCache.add(uid); spawnShotFromEvent(NET.getMyId() || "", payload, State.bullets); }
                } else {
                    NET.sendShootRequest(payload);
                }
                HUD.update();
            },
            movePlayer(dt) {
                let ax = 0, ay = 0; const k = Input.keys;
                if (k.has('KeyW')) ay -= 1; if (k.has('KeyS')) ay += 1; if (k.has('KeyA')) ax -= 1; if (k.has('KeyD')) ax += 1;
                if (ax || ay) { const [nx, ny] = MathX.norm(ax, ay); State.player.vx += nx * State.player.speed; State.player.vy += ny * State.player.speed; }
                State.player.vx *= Config.friction; State.player.vy *= Config.friction;
                State.player.x += State.player.vx; State.player.y += State.player.vy;
                Systems.resolveAABB(State.player, State.player.size);
            },
            moveBullets(dt) {
                for (let i = State.bullets.length - 1; i >= 0; i--) {
                    const b = State.bullets[i];
                    b.x += b.vx; b.y += b.vy; b.life -= dt;
                    let hit = false;
                    for (const o of State.obstacles) {
                        if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) { hit = true; break; }
                    }
                    if (hit) { Systems.puff(b.x, b.y, 6, 1.1, 200, 'rgba(230,236,243,.6)'); State.bullets.splice(i, 1); continue; }
                    if (b.x < -50 || b.y < -50 || b.x > W + 50 || b.y > H + 50 || b.life <= 0) State.bullets.splice(i, 1);
                }
            },
            moveRemoteBullets(dt) {
                for (let i = Remote.bullets.length - 1; i >= 0; i--) {
                    const b = Remote.bullets[i];
                    b.x += b.vx; b.y += b.vy; b.life -= dt;
                    if (b.x < -50 || b.y < -50 || b.x > W + 50 || b.y > H + 50 || b.life <= 0) Remote.bullets.splice(i, 1);
                }
            },
            moveEnemies(dt) {
                for (const e of State.enemies) {
                    const dx = State.player.x - e.x, dy = State.player.y - e.y, d = Math.hypot(dx, dy) + 1e-4;
                    const s = e.spd * (1 + Math.min(0.6, 30 / d));
                    e.vx = (dx / d) * s; e.vy = (dy / d) * s;
                    e.x += e.vx; e.y += e.vy;
                    Systems.resolveAABB(e, e.size);
                }
            },
            resolveAABB(ent, size) {
                const b = Config.bounds;
                ent.x = MathX.clamp(ent.x, b.x + size / 2, b.x + b.w - size / 2);
                ent.y = MathX.clamp(ent.y, b.y + size / 2, b.y + b.h - size / 2);
                for (const o of State.obstacles) {
                    const ex = ent.x - size / 2, ey = ent.y - size / 2, ew = size, eh = size;
                    if (ex < o.x + o.w && ex + ew > o.x && ey < o.y + o.h && ey + eh > o.y) {
                        const dx1 = (o.x + o.w) - ex, dx2 = (ex + ew) - o.x, dy1 = (o.y + o.h) - ey, dy2 = (ey + eh) - o.y;
                        const m = Math.min(dx1, dx2, dy1, dy2);
                        if (m === dx1) ent.x = o.x + o.w + size / 2;
                        else if (m === dx2) ent.x = o.x - size / 2;
                        else if (m === dy1) ent.y = o.y + o.h + size / 2;
                        else ent.y = o.y - size / 2;
                    }
                }
            },
            damageOnTouch(dt) {
                for (const e of State.enemies) {
                    if (Math.hypot(State.player.x - e.x, State.player.y - e.y) < e.size + State.player.size - 6) {
                        State.player.hp -= 10 * dt / 1000;
                        if (State.player.hp <= 0) { Game.gameOver(); return; }
                        if (Math.random() < 0.2) Systems.blood(State.player.x, State.player.y);
                    }
                }
            },
            bulletsVsEnemies() {
                for (let i = State.enemies.length - 1; i >= 0; i--) {
                    const e = State.enemies[i];
                    for (let j = State.bullets.length - 1; j >= 0; j--) {
                        const b = State.bullets[j];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                            e.hp -= (b.damage || 20);
                            if (e.hp <= 0) {
                                Systems.puff(e.x, e.y, 18, 2.4, 500, 'rgba(255,107,107,.9)');
                                State.enemies.splice(i, 1);
                                State.score += 10;
                            }
                            if (b.pierce && b.pierce > 0) { b.pierce--; Systems.blood(e.x, e.y); }
                            else { State.bullets.splice(j, 1); Systems.blood(e.x, e.y); }
                            break;
                        }
                    }
                }
            },
            spawnPickup() {
                const options = [2, 3, 3];
                const type = options[Math.floor(Math.random() * options.length)];
                const b = Config.bounds; const w = 28, h = 28;
                for (let tries = 0; tries < 50; tries++) {
                    const x = MathX.rand(b.x + 20, b.x + b.w - w - 20), y = MathX.rand(b.y + 20, b.y + b.h - h - 20);
                    const startSafe = { x: W / 2 - 160, y: H / 2 - 160, w: 320, h: 320 };
                    let bad = x < startSafe.x + startSafe.w && x + w > startSafe.x && y < startSafe.y + startSafe.h && y + h > startSafe.y;
                    for (const o of State.obstacles) { if (x < o.x + o.w && x + w > o.x && y < o.y + o.h && y + h > o.y) { bad = true; break; } }
                    if (!bad) { State.pickups.push({ x, y, w, h, type }); break; }
                }
            },
            tryPickup() {
                for (let i = State.pickups.length - 1; i >= 0; i--) {
                    const p = State.pickups[i];
                    if (State.player.x > p.x && State.player.x < p.x + p.w && State.player.y > p.y && State.player.y < p.y + p.h) {
                        const w = Weapons[p.type - 1];
                        State.ammo[p.type] = (State.ammo[p.type] || 0) + w.pickup;
                        State.pickups.splice(i, 1);
                        HUD.update();
                    }
                }
            },
            spawnEnemy() {
                const edge = Math.floor(MathX.rand(0, 4)); let x, y;
                if (edge === 0) { x = MathX.rand(0, W); y = -20; }
                if (edge === 1) { x = W + 20; y = MathX.rand(0, H); }
                if (edge === 2) { x = MathX.rand(0, W); y = H + 20; }
                if (edge === 3) { x = -20; y = MathX.rand(0, H); }
                const typeRand = Math.random();
                let type, size, hp, spd, color;
                if (typeRand < 0.75) { type = 'normal'; size = MathX.rand(16, 24); hp = 10 + State.wave * 2 + MathX.rand(-2, 2); spd = 0.55 + Math.min(1.2, State.wave * 0.05) + MathX.rand(-0.08, 0.08); color = '#ff6b6b'; }
                else { type = 'big'; size = MathX.rand(36, 44); hp = 150 + State.wave * 6 + MathX.rand(-4, 4); spd = 0.35 + Math.min(0.7, State.wave * 0.03) + MathX.rand(-0.05, 0.05); color = '#ff9f43'; }
                State.enemies.push({ x, y, vx: 0, vy: 0, size, hp, spd, type, color });
            },
            nextWave() {
                State.wave++;
                for (let i = 0; i < Math.min(Config.spawn.perWaveBase + State.wave * Config.spawn.perWaveScale, Config.spawn.maxBatch); i++) Systems.spawnEnemy();
                State.player.hp = MathX.clamp(State.player.hp + 12, 0, 100); Systems.flash('#4de2cc');
            },
            puff(x, y, n = 12, speed = 3, life = 500, c = 'rgba(255,255,255,.8)') { for (let i = 0; i < n; i++) { const a = MathX.rand(0, Math.PI * 2), v = MathX.rand(0.5, speed); State.particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life, c }); } },
            blood(x, y) { Systems.puff(x, y, 16, 2.6, 700, 'rgba(255,80,80,.8)'); },
            flash(color) { State.particles.push({ x: W / 2, y: H / 2, vx: 0, vy: 0, life: 160, c: color, full: true }); },
            updateParticles(dt) { for (let i = State.particles.length - 1; i >= 0; i--) { const p = State.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= dt; if (p.life <= 0) State.particles.splice(i, 1); } }
        };

        // Spawner bullets ud fra ShootEvent (bruges af alle)
        function spawnShotFromEvent(shooterId, payload, targetList) {
            const w = Weapons[payload.weaponIndex];
            const baseAng = payload.angle;
            for (let i = 0; i < w.pellets; i++) {
                const spread = w.spread * detRandSym(shooterId, payload.uid, i);
                const ang = baseAng + spread;
                const vx = Math.cos(ang) * w.speed, vy = Math.sin(ang) * w.speed;
                targetList.push({
                    x: payload.x + Math.cos(baseAng) * (State.player.size + 8),
                    y: payload.y + Math.sin(baseAng) * (State.player.size + 8),
                    vx, vy, life: w.life, damage: w.dmg, pierce: w.pierce
                });
            }
            Systems.puff(payload.x + Math.cos(baseAng) * 14, payload.y + Math.sin(baseAng) * 14, 6 + w.pellets, 1.2, 160, 'rgba(255,255,255,.5)');
        }

        /* ===================== Render ===================== */
        const Render = {
            draw() {
                ctx.clearRect(0, 0, W, H);
                const b = Config.bounds;

                // bg & grid
                ctx.save(); ctx.fillStyle = '#0a0e1b'; ctx.fillRect(0, 0, W, H);
                ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = 2; ctx.strokeRect(b.x - 10, b.y - 10, b.w + 20, b.h + 20);
                ctx.globalAlpha = .06;
                for (let x = b.x; x < b.x + b.w; x += 40) { ctx.beginPath(); ctx.moveTo(x, b.y); ctx.lineTo(x, b.y + b.h); ctx.stroke(); }
                for (let y = b.y; y < b.y + b.h; y += 40) { ctx.beginPath(); ctx.moveTo(b.x, y); ctx.lineTo(b.x + b.w, y); ctx.stroke(); }
                ctx.globalAlpha = 1; ctx.restore();

                // obstacles
                ctx.save(); for (const o of State.obstacles) { ctx.fillStyle = '#1e243f'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.strokeRect(o.x + .5, o.y + .5, o.w - 1, o.h - 1); } ctx.restore();

                // pickups
                ctx.save(); for (const p of State.pickups) { let col = '#ffb84d'; if (p.type === 3) col = '#4da6ff'; ctx.fillStyle = col; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.strokeRect(p.x + .5, p.y + .5, p.w - 1, p.h - 1); } ctx.restore();

                // particles
                for (const p of State.particles) {
                    if (p.full) { const t = MathX.clamp(p.life / 160, 0, 1); ctx.save(); ctx.globalAlpha = t * .25; ctx.fillStyle = p.c; ctx.fillRect(0, 0, W, H); ctx.restore(); }
                    else { ctx.save(); ctx.globalAlpha = MathX.clamp(p.life / 500, 0, 1); ctx.fillStyle = p.c; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); ctx.restore(); }
                }

                // helper til at tegne spiller med våbenretning + navn
                function drawPlayer(x, y, aim, isSelf, weaponIndex, nameText) {
                    const head = 12, body = 22;
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(aim || 0);
                    // krop
                    ctx.fillStyle = isSelf ? '#1b2a57' : '#2a335f';
                    ctx.fillRect(-body / 2, -body / 2, body, body);
                    // hoved
                    ctx.fillStyle = isSelf ? '#4de2cc' : '#9aa7ff';
                    ctx.fillRect(body / 2 - 2, -head / 2, head, head);
                    // pistol/barrel
                    ctx.fillStyle = '#e7ecf3';
                    ctx.fillRect(body / 2 + head - 2, -3, 16, 6);
                    ctx.restore();

                    // navn over spilleren
                    if (nameText) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(0,0,0,.45)';
                        ctx.fillRect(x - 50, y - 36, 100, 20);
                        ctx.fillStyle = '#e7ecf3';
                        ctx.font = '700 14px system-ui, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(nameText, x, y - 22);
                        ctx.restore();
                    }

                    // lille våbenprik
                    ctx.save();
                    ctx.fillStyle = ['#e7ecf3', '#ffb84d', '#4da6ff'][weaponIndex ?? 0] || '#e7ecf3';
                    ctx.fillRect(x + 16, y - 3, 8, 6);
                    ctx.restore();
                }

                // lokal spiller
                drawPlayer(State.player.x, State.player.y, State.aim, true, State.weaponIndex, State.myName);

                // andre spillere (glattet position + deres aim)
                for (const [id, p] of NET.getOthers()) {
                    drawPlayer(p.x, p.y, p.aim || 0, false, p.weaponIndex, NET.getName(id));
                }

                // enemies
                for (const e of State.enemies) {
                    ctx.save(); ctx.translate(e.x, e.y); ctx.fillStyle = e.color || '#ff6b6b';
                    ctx.fillRect(-e.size / 2, -e.size / 2, e.size, e.size);
                    ctx.fillStyle = '#10131f'; ctx.fillRect(-4, -4, 3, 3); ctx.fillRect(1, -4, 3, 3);
                    ctx.restore();
                }

                // bullets
                ctx.save(); ctx.fillStyle = '#e7ecf3';
                const list = NET.getIsHost() ? State.bullets : Remote.bullets;
                for (const b2 of list) ctx.fillRect(b2.x - 2, b2.y - 2, 4, 4);
                ctx.restore();

                if (Game.paused) {
                    ctx.save(); ctx.globalAlpha = .6; ctx.fillStyle = '#0b0f1e'; ctx.fillRect(0, 0, W, H);
                    ctx.globalAlpha = 1; ctx.fillStyle = '#fff'; ctx.font = '700 36px system-ui, sans-serif';
                    ctx.textAlign = 'center'; ctx.fillText('PAUSE', W / 2, H / 2); ctx.restore();
                }
            }
        };

        /* ===================== Game ===================== */
        const Game = {
            running: false, paused: false, _sentObstacles: false,
            init() {
                MapGen.makeOpenArena();
                State.enemies.length = 0; State.bullets.length = 0; Remote.bullets.length = 0;
                State.particles.length = 0; State.pickups.length = 0;
                State.player.x = W / 2; State.player.y = H / 2; State.player.vx = 0; State.player.vy = 0; State.player.hp = Config.player.hp; State.player.alive = true;
                State.weaponIndex = 0; State.ammo[2] = 0; State.ammo[3] = 0;
                State.score = 0; State.wave = 1; State.spawnTimer = 0; State.pickupTimer = 0; State.lastFire = -1e9;
                for (let i = 0; i < 2; i++) State.pickups.push({ x: Config.bounds.x + 80 + i * 60, y: Config.bounds.y + 80, w: 28, h: 28, type: i === 0 ? 2 : 3 });
                HUD.update(); HUD.showOverlay();
                Game._sentObstacles = false;
            },
            start(name) {
                State.myName = name.trim().slice(0, 20);
                NET.start().then(() => {
                    NET.setName(State.myName);
                });
                this.running = true; this.paused = false; HUD.hideOverlay();
                this._acc = 0; this._last = performance.now();
                requestAnimationFrame(this.loop.bind(this));

                // net tick (20 Hz): host sender enemies + obstacles (én gang)
                (function netTick() {
                    const now = performance.now();
                    if (!netTick._last || now - netTick._last > 50) {
                        netTick._last = now;
                        if (NET.getIsHost()) {
                            const es = State.enemies.map(e => ({ x: e.x, y: e.y, size: e.size, hp: e.hp, spd: e.spd, type: e.type, color: e.color }));
                            NET.sendEnemiesSnapshot(es);
                            if (!Game._sentObstacles) {
                                NET.sendObstaclesSnapshot(State.obstacles.map(o => ({ x: o.x, y: o.y, w: o.w, h: o.h })));
                                Game._sentObstacles = true;
                            }
                        }
                    }
                    requestAnimationFrame(netTick);
                })();
            },
            loop(ts) {
                if (!this.running) return;
                const frame = ts - this._last; this._last = ts;
                if (!this.paused) {
                    this._acc = Math.min(this._acc + frame, 250);
                    while (this._acc >= Config.fixedDt) { this.update(Config.fixedDt); this._acc -= Config.fixedDt; }
                    this.render();
                }
                requestAnimationFrame(this.loop.bind(this));
            },
            update(dt) {
                // sigtevinkel (bruges til våbenretning + sendes i UpdateSelf)
                const dx = Input.mouse.x - State.player.x, dy = Input.mouse.y - State.player.y;
                State.aim = Math.atan2(dy, dx);

                if (Input.mouse.down) Systems.shoot();
                Systems.movePlayer(dt);

                if (NET.getIsHost()) {
                    Systems.moveEnemies(dt);
                    Systems.damageOnTouch(dt);
                    Systems.bulletsVsEnemies();
                    Systems.moveBullets(dt);
                } else {
                    Systems.moveRemoteBullets(dt);
                }

                Systems.updateParticles(dt);
                Systems.tryPickup();

                // spawns/waves kun på host
                State.spawnTimer -= dt; State.pickupTimer -= dt;
                if (NET.getIsHost()) {
                    if (State.spawnTimer <= 0) {
                        const perSec = Math.min(0.5 + State.wave * 0.18, 2.0);
                        State.spawnTimer = 1000 / perSec; Systems.spawnEnemy();
                    }
                    if (State.pickupTimer <= 0 && State.pickups.length < Config.pickups.max) {
                        State.pickupTimer = MathX.rand(Config.pickups.spawnMin, Config.pickups.spawnMax);
                        Systems.spawnPickup();
                    }
                    if (State.score > State.wave * 150) Systems.nextWave();
                }

                // send lokal state (inkl. aim)
                NET.sendState();

                // smoothing af andre
                for (const [, o] of NET.getOthers()) {
                    const s = 0.18;
                    o.x += (o.tx - o.x) * s;
                    o.y += (o.ty - o.y) * s;
                }

                HUD.update();
            },
            render() { Render.draw(); },
            gameOver() {
                if (!State.player.alive) return;
                State.player.alive = false; this.paused = false;
                if (State.score > State.highScore) { State.highScore = State.score; Save.highScore = State.highScore; }
                HUD.showOverlay();
            }
        };

        /* ===================== Wire up startmenu ===================== */
        Game.init();

        nameInput.addEventListener('input', () => {
            startBtn.disabled = nameInput.value.trim().length === 0;
        });

        startBtn.addEventListener('click', () => {
            const name = nameInput.value.trim();
            if (!name) return;
            Game.start(name);
        });

        document.addEventListener('keydown', (e) => {
            if (hud.startOverlay && hud.startOverlay.style.display !== 'none') {
                if (e.key === 'Enter' && !startBtn.disabled) startBtn.click();
            }
        });

        if (hud.restartBtn) hud.restartBtn.addEventListener('click', () => Game.init());

        /* ===================== Minimal tests ===================== */
        (function runTests() {
            const assert = (c, m) => { if (!c) throw new Error(m); };
            const test = (n, f) => { try { f(); console.log('✅', n); } catch (e) { console.error('❌', n, e); } };
            test('Default weapon = Pistol', () => assert(Weapons[0].name === 'Pistol', 'not pistol'));
        })();
    </script>
</body>
</html>
